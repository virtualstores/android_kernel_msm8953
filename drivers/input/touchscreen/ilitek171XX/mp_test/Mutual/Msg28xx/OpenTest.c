/*
 * Copyright (C) 2006-2017 ILITEK TECHNOLOGY CORP.
 *
 * Description: ILITEK I2C touchscreen driver for linux platform.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see the file COPYING, or write
 * to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Author: Dicky Chiang
 * Maintain: Luca Hsu, Tigers Huang
 */
 
#include "OpenTest.h"

int _gSenseLineNum = 0;
int _gDriveLineNum = 0;
int _gWaterProofNum = 0;
int _gDeltaC[MAX_MUTUAL_NUM] = {0};
int _gDeltaCVA[MAX_MUTUAL_NUM] = {0};
int * _gResult;

void Msg28xxSetMutualCsubViaDBbus(s16 nCSub)
{
    u8 nBaseLen = 6;
    u16 nFilter = 0x3F;
    u16 nLastFilter = 0xFFF;
    u8 nBasePattern = nCSub & nFilter;
    u8 nPattern;
    u16 n16BitsPattern;
    u16 nCSub16Bits[5] = {0};
    int i;

    printk("*** %s() ***\n", __func__);

    for(i=0; i<5; i++)
    {
        if(i == 0)
        {
            nPattern = nBasePattern;    //Patn => Pattern
        }

        n16BitsPattern = ((nPattern & 0xF) << nBaseLen*2) | (nPattern << nBaseLen) | nPattern;

        if(i == 4)
        {
            nCSub16Bits[i] = n16BitsPattern & nLastFilter;
        }
        else
        {
            nCSub16Bits[i] = n16BitsPattern;
        }
        nPattern = (u8)((n16BitsPattern >> 4) & nFilter);
    }

    RegSet16BitValue(0x215C, 0x1FFF);

    for (i = 0; i < 5; i++)
    {
        RegSet16BitValue(0x2148 + 2 * i, nCSub16Bits[i]);
        RegSet16BitValue(0x2152 + 2 * i, nCSub16Bits[i]);
    }
}

void Msg28xxAFEGainOne(void)
{
    // AFE gain = 1X
    u16 nAfeGain = 0;
    u16 nDriOpening = 0;
    u8 nRegData = 0;
    u16 nAfeCoef = 0;
    u16 i = 0;

    printk("*** %s() ***\n", __func__);
    nRegData = RegGetLByteValue(0x1312); //get dri num
    nDriOpening = nRegData;

    ///filter unit gain
    if (nDriOpening == 11 || nDriOpening == 15)
    {
        RegSet16BitValue(0x1318, 0x4470);
    }
    else if (nDriOpening == 7 || nDriOpening == 4)
    {
        RegSet16BitValue(0x1318, 0x4460);
    }
    else if (nDriOpening == 1)
    {
    	RegSet16BitValue(0x1318, 0x4440);
    }

    RegSet16BitValue(0x131A, 0x4444);

    ///AFE coef
    nRegData = RegGetLByteValue(0x101A);
    nAfeCoef = 0x10000 / nRegData;
    RegSet16BitValue(0x13D6, nAfeCoef);

    ///AFE gain
    if (nDriOpening == 7 || nDriOpening == 15 || nDriOpening == 4 || nDriOpening == 1 )
    {
        nAfeGain = 0x0040;
    }
    else if (nDriOpening == 11)
    {
        nAfeGain = 0x0055;
    }

    for (i = 0; i < 13; i++)
    {
        RegSet16BitValue(0x2160 + 2 * i, nAfeGain);
    }

    ///AFE gain: over write enable
    RegSet16BitValue(0x217A, 0x1FFF);
    RegSet16BitValue(0x217C, 0x1FFF);

    /// all AFE Cfb use defalt (50p)
    RegSet16BitValue(0x1508, 0x1FFF);// all AFE Cfb: SW control
    if (ptMutualMpTest->Pattern_type == 5)
    {
    	switch (ptMutualMpTest->Open_test_cfb)
        {
        	case 0:
            case 2:
            	SetCfb(_20p);
                break;
            case 1:
                SetCfb(_10p);
                break;
            case 3:
                SetCfb(_30p);
                break;
            case 4:
                SetCfb(_40p);
                break;
            case 5:
                SetCfb(_50p);
                break;
        }
    	printk("SetCfb : %d\n", ptMutualMpTest->Open_test_cfb);
    }
    else
    {
    	RegSet16BitValue(0x1550, 0x0000);// all AFE Cfb use defalt (50p)
    }


    /// reg_hvbuf_sel_gain
    RegSet16BitValue(0x1564, 0x0077);

    ///ADC: AFE Gain bypass
    RegSet16BitValue(0x1260, 0x1FFF);
}

void Msg28xxCalibrateMutualCsub(s16 nCSub)
{
    u8 nChipVer;

    printk("*** %s() ***\n", __func__);

    nChipVer = RegGetLByteValue(0x1ECE);
    printk("*** Msg28xx Open Test# Chip ID = %d ***\n", nChipVer);

    if (nChipVer != 0)
        RegSet16BitValue(0x10F0, 0x0004);//bit2

    Msg28xxSetMutualCsubViaDBbus(nCSub);
    Msg28xxAFEGainOne();
}

void Msg28xxAnaEnableChargePump(u8 enable_charge_pump)
{
    u16 val = 0;

    printk("*** %s() ***\n", __func__);
    if (!enable_charge_pump)
    {
        RegSet16BitValueOff(0x1560, BIT0 | BIT1);	//high v buf en, close


        val = RegGet16BitValue(0x1566); //set
        val |= BIT12;
        RegSet16BitValue(0x1566, val);        //LV on

        RegSet16BitValueOff(0x1566, BIT8 | BIT9 | BIT10 | BIT11);

        RegSet16BitValueOff(0x1570, BIT8 | BIT10);

        RegSet16BitValueOff(0x1580, BIT0 | BIT4);

        val = RegGet16BitValue(0x1464); //set
        val |= BIT2 | BIT3;
        RegSet16BitValue(0x1464, val);
    }
    else
    {
        val = RegGet16BitValue(0x1560); //set
        val |= 0x03;
        RegSet16BitValue(0x1560, val); //high v buf en, close

        RegSet16BitValueOff(0x1566, BIT12);        //LV on

        RegSet16BitValueOff(0x1566, BIT8 | BIT9 | BIT10 | BIT11);        //LV on

        val = RegGet16BitValue(0x1566); //set
        val |= BIT8 | BIT10;
        RegSet16BitValue(0x1566, val);

        val = RegGet16BitValue(0x1570); //cset
        val |= BIT10;
        RegSet16BitValue(0x1570, val);

        val = RegGet16BitValue(0x1580); //set
        val |= BIT0 | BIT1;
        RegSet16BitValue(0x1580, val);

        RegSet16BitValueOff(0x1464, BIT2 | BIT3);
    }
}

void Msg28xxOpenSineModeSetting(void)
{
//	u8 nCfb = ptMutualMpTest->Open_test_cfb;
    printk("*** %s() ***\n", __func__);
	Msg28xxAnaEnableChargePump(ptMutualMpTest->Open_test_chargepump);
	switch (ptMutualMpTest->Open_test_cfb) {
		case 0:
	    case 2:
	     	SetCfb(_20p);
	        break;
	    case 1:
	    	SetCfb(_10p);
	        break;
	    case 3:
	        SetCfb(_30p);
	        break;
	    case 4:
	        SetCfb(_40p);
	        break;
	    case 5:
	        SetCfb(_50p);
	        break;
	}
	printk("SetCfb : %d\n", ptMutualMpTest->Open_test_cfb);
}

void Msg28xxUpdateAnaChargeDumpSetting(void)
{
    printk("*** %s() ***\n", __func__);
    RegSet16BitValueByAddressMode(0x1018, 0x001F, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x1019, 0x003f, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x101a, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub0
    RegSet16BitValueByAddressMode(0x101b, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub1
    RegSet16BitValueByAddressMode(0x101c, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub2
    RegSet16BitValueByAddressMode(0x101d, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub3
    RegSet16BitValueByAddressMode(0x101e, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub4
    RegSet16BitValueByAddressMode(0x101f, 0x0000, ADDRESS_MODE_16BIT);

    RegSet16BitValueByAddressMode(0x100d, 0x0020, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x1103, 0x0020, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x1104, 0x0020, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x1302, 0x0020, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x136b, 0x10000 / 0x20, ADDRESS_MODE_16BIT);    // AFE_coef, set value by 0x10000 dividing register 0x100d value
    RegSet16BitValueByAddressMode(0x1b30, 0x0020, ADDRESS_MODE_16BIT);
}

s32 Msg28xxReEnterMutualMode(u16 nFMode)
{
	printk("*** %s() ***\n", __func__);

	StartMCU();
	//EnterDBBus();
	Msg28xxDBBusReEnter();
	//usleep(50000);
    mdelay(50);
	RegSet16BitValue(0x1402, nFMode);
	printk("nFMode = %x\n", nFMode);
	if (Msg28xxCheckSwitchStatus()<0) {
		printk("*** Msg28xx MP Test# CheckSwitchStatus failed! ***\n");
	    return -1;
	}

	StopMCU();
	RegSet16BitValue(0x3D08, 0xFEFF);//open timer
	return 0;
}

s32 Msg28xxGetDeltaC(s32 *pDeltaC)
{
    s16 * pRawData = NULL;
	//s16 pRawData[MAX_CHANNEL_SEN * 2 * MAX_CHANNEL_DRV];
	//s16 nRawDataOverlapDone[_gSenseLineNum][_gDriveLineNum];
	s16 **nRawDataOverlapDone = NULL;
    //s16 nDeltaC[MAX_MUTUAL_NUM] = {0};
    u16 nDrvPos = 0, nSenPos = 0, nShift = 0;
    u16 nSenNumBak = 0;
    u16 nDrvNumBak = 0;
    s16 i, j;

    printk("*** %s() ***\n", __func__);

    pRawData = (s16 *)kmalloc(sizeof(s16) * MAX_CHANNEL_SEN*2 * MAX_CHANNEL_DRV, GFP_KERNEL);
    nRawDataOverlapDone = (s16 **)kmalloc(_gSenseLineNum * sizeof(void *), GFP_KERNEL);
    for (i = 0; i < _gSenseLineNum; ++i)
    {
    	nRawDataOverlapDone[i] = (s16 *)kmalloc(_gDriveLineNum * sizeof(s16), GFP_KERNEL);
    }

    memset(pRawData, 0, sizeof(*pRawData));
    memset(nRawDataOverlapDone, 0, sizeof(**nRawDataOverlapDone));

    if(Msg28xxGetMutualOneShotRawIIR(pRawData, &nSenNumBak, &nDrvNumBak) < 0)
    {
        printk("*** Msg28xx Open Test# GetMutualOneShotRawIIR failed! ***\n");
        return -1;
    }

    printk("*** Msg28xx Open Test# nSenNumBak=%d nDrvNumBak=%d ***\n", nSenNumBak, nDrvNumBak);

    for (i = 0; i < _gSenseLineNum; i++)
    {
    	for (j = 0; j < _gDriveLineNum; j++)
    	{
    		nRawDataOverlapDone[i][j] = UN_USE_SENSOR;
    	}
    }

    printk("*** Msg28xx Open Test# *****\n");

    for (i = 0; i < nSenNumBak; i++)
    {
        for (j = 0; j < nDrvNumBak; j++)
        {
            nShift = (u16)(i * nDrvNumBak + j);

            nDrvPos = ptMutualMpTest->sensorInfo.mapping[nShift].Y;
            nSenPos = ptMutualMpTest->sensorInfo.mapping[nShift].X;

            if (nDrvPos >= _gDriveLineNum || nSenPos >= _gSenseLineNum) 
                continue;

            if (nDrvPos != 0xFF && nSenPos != 0xFF)
            {
                nRawDataOverlapDone[nSenPos][nDrvPos] = pRawData[i*MAX_CHANNEL_DRV+j];
            }
        }
    }

    printk("*** Msg28xx Open Test# Transfer nRawDataOverlapDone to pDeltaC");
    for (i = 0; i < _gSenseLineNum; i++)
    {
        for (j = 0; j < _gDriveLineNum; j++)
        {
            nShift = (u16)(i * _gDriveLineNum + j);
            pDeltaC[nShift] = (s32)nRawDataOverlapDone[i][j];
        }
    }

    printk("*** Msg28xx Open Test# gDeltaC ***\n");
    DebugShowArray2(pDeltaC, _gSenseLineNum * _gDriveLineNum, -32, 10, _gSenseLineNum);
    kfree(pRawData);
    kfree(nRawDataOverlapDone);
    return 0;
}

void _HalSramEnterAccessMode(void)
{
    printk("*** %s() ***\n", __func__);
	// change to R2 mode
	RegMask16BitValue(0x2149, BIT5, BIT5, ADDRESS_MODE_16BIT);
    // SRAM using MCU clock
	RegMask16BitValue(0x1E11, BIT13, BIT13, ADDRESS_MODE_16BIT);
}

void _HalSramExitAccessMode(void)
{
	printk("*** %s() ***\n", __func__);
	// change to R2 mode
	RegMask16BitValue(0x2149, BIT5, 0, ADDRESS_MODE_16BIT);
	// SRAM using MCU clock
	RegMask16BitValue(0x1E11, BIT13, 0, ADDRESS_MODE_16BIT);
}

void Msg28xxOpenSwcapModeSetting(void)
{
	u16 chargeT = 0x0C, dumpT = 0x06;

	printk("*** %s() ***\n", __func__);
    
	// Stop mcu
	StopMCU();

	Msg28xxCalibrateMutualCsub(ptMutualMpTest->Open_test_csub);
	Msg28xxAnaChangeCDtime(chargeT, dumpT);
	Msg28xxAnaEnableChargePump(DISABLE);
	RegSet16BitValue(0x156A, 0x000A); ///DAC com voltage
	Msg28xxUpdateAnaChargeDumpSetting();
	Msg28xxAnaSwReset();
}

s32 ObtainOpenValue_VA_FW_v1007(void)
{
	if(Msg28xxGetDeltaC(_gDeltaC) < 0)	{
		printk("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
		return -1;
	}
	return 0;
}

void _WriteDQMem_8bit(u16 addr, u8 data)
{
	u8 read_buf[4] = {0};
    u16 high_16, low_16 = 0;
    u16 read_addr = 0;

    printk("*** %s() ***\n", __func__);

    read_addr = addr - (addr % 4);

    RegGet16BitByteValueBuf(read_addr, read_buf, sizeof(read_buf) / sizeof(read_buf[0]));

    read_buf[addr % 4] = data;
    printk("read_buf:0x%02x 0x%02x 0x%02x  0x%02x", read_buf[0], read_buf[1], read_buf[2], read_buf[3]);
    low_16 = (((u16)read_buf[1] << 8) | read_buf[0]);
    high_16 = (((u16)read_buf[3] << 8) | read_buf[2]);

    RegSet16BitValue(read_addr + 2, low_16);
    RegSet16BitValue(read_addr, high_16);
}

s32 Msg28xxObtainOpenValue_Keys_FW_v1007(int *pkeyarray)
{
	int k;
//	u8 u8ShotData[16];
	//u16 nSf = ptMutualMpTest->sub_frame;
	u8 nRegData = 0, nSf = 0;
	u16 numKey = 0, drvNum = 0, senNum = 0;
//	u16 keySen = ptMutualMpTest->PAD2Drive[ptMutualMpTest->sensorInfo.KeyDrv_o - 1];
    u32 shift = 0;

	printk("*** %s() ***\n", __func__);
	nRegData = RegGetLByteValue(0x130A);
	nSf = nRegData>>4;
	SetCfb(_50p);
	Msg28xxAnaEnableChargePump(DISABLE);
	//Msg28xxAnaSwReset();
	if (Msg28xxGetValueR(_gDeltaCVA) < 0) {
	//if(Msg28xxGetDeltaC(_gDeltaCVA) < 0) {
		printk("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
	    return -1;
	}

	numKey = ptMutualMpTest->sensorInfo.numKey;
	drvNum = ptMutualMpTest->sensorInfo.numDrv;
	senNum = ptMutualMpTest->sensorInfo.numSen;

	if (MAX(numKey, 3) > 3)
	    numKey = 3;
	    shift = 0;
	for (k = 0; k < numKey; k++) {
		pkeyarray[k] = _gDeltaCVA[k];
	}
	return 0;
}

s32 ObtainOpenValue_VA(void)
{
	int i, isf = 0;
	u8 u8ShotData[16];
	//u16 nSf = ptMutualMpTest->sub_frame;
	u8 nSf = 0, nRegData = 0;
	u16 addr = 0x6410;
	u16 keySen = ptMutualMpTest->PAD2Drive[ptMutualMpTest->sensorInfo.KeyDrv_o - 1];

	printk("*** %s() ***\n", __func__);
	nRegData = RegGetLByteValue(0x130A);
	nSf = nRegData>>4;
	_HalSramEnterAccessMode();
	for (isf = 0; isf < nSf; isf++) {
		memset(u8ShotData, 0, sizeof(u8ShotData));
		Msg28xxDBBusReadDQMemStart();
		//RegGetXByteValue(u8ShotData, addr + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0]));
        RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData) / sizeof(u8ShotData[0]), MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		DebugShowArray2(u8ShotData, 16, 16, 16, 16);
		// Find key index, then replace key sensor by assign sensor 56(0x38).
		printk("Check KeySen : %d", keySen);
		for (i = 0; i < (sizeof(u8ShotData) / sizeof(u8ShotData[0])); i++) {
			printk("Loop Count : %d", i);
			if (u8ShotData[i] == keySen)
				_WriteDQMem_8bit(addr + isf * 0x20 + i, 0x38);
		}
		//RegGetXByteValue(u8ShotData, addr + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0]));
        RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData) / sizeof(u8ShotData[0]), MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		DebugShowArray2(u8ShotData, 16, 16, 16, 16);
		Msg28xxDBBusReadDQMemEnd();
	}
	_HalSramExitAccessMode();
	Msg28xxAnaSwReset();
	if(Msg28xxGetDeltaC(_gDeltaC) < 0)	{
		printk("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
	    return -1;
	}
	printk("*** ObtainOpenValue_VA End ***\n");
	return 0;
}

s32 Msg28xxObtainOpenValue_Keys(int *pkeyarray)
{
	int k;
	int i, isf = 0;
	u8 u8ShotData[16];
	//u16 nSf = ptMutualMpTest->sub_frame;
	u8 nSf = 0, nRegData = 0;
	u16 addr = 0x6410, numKey = 0, drvNum = 0, senNum = 0;
	u16 keySen = 0;
    u32 shift = 0;

    keySen = ptMutualMpTest->PAD2Drive[ptMutualMpTest->sensorInfo.KeyDrv_o - 1];

	printk("*** %s() ***\n", __func__);

	nRegData = RegGetLByteValue(0x130A);
	nSf = nRegData>>4;
	SetCfb(_50p);
	Msg28xxAnaEnableChargePump(DISABLE);
	_HalSramEnterAccessMode();
	for (isf = 0; isf < nSf; isf++) {
		memset(u8ShotData, 0, sizeof(u8ShotData) / sizeof(u8ShotData[0]));
		Msg28xxDBBusReadDQMemStart();
		//RegGetXByteValue(u8ShotData, addr + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0]));
        RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData) / sizeof(u8ShotData[0]), MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		// Find key index, then replace key sensor by assign sensor 56(0x38).
		for (i = 0; i < (sizeof(u8ShotData) / sizeof(u8)); i++) {
			printk("Loop Count : %d", i);
			if (u8ShotData[i] == 0x38)
			{
				_WriteDQMem_8bit(addr + isf * 0x20 + i, keySen);
				printk("keySen : %d", keySen);
			}
		}
		//RegGetXByteValue(u8ShotData, addr + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0]));
        RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData) / sizeof(u8ShotData[0]), MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		Msg28xxDBBusReadDQMemEnd();
	}
	_HalSramExitAccessMode();
	Msg28xxAnaSwReset();
	if(Msg28xxGetDeltaC(_gDeltaCVA) < 0) {
		printk("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
	    return -1;
	}
	numKey = ptMutualMpTest->sensorInfo.numKey;
	drvNum = ptMutualMpTest->sensorInfo.numDrv;
	senNum = ptMutualMpTest->sensorInfo.numSen;
	if (MAX(numKey, 3) > 3)
	    numKey = 3;

	for (k = 0; k < numKey; k++) {
		shift = (ptMutualMpTest->KeySen[k] - 1) * ptMutualMpTest->sensorInfo.KeyDrv_o + ptMutualMpTest->sensorInfo.KeyDrv_o - 1;
		pkeyarray[k] = _gDeltaCVA[shift];
	}
	return 0;
}

s32 Msg28xxopen_latter_FW_v1007(u16 nFMode)
{
    int *keyArray = NULL, k, numKey = 0;
    u16 shift = 0;

    printk("*** %s() ***\n", __func__);

    // Stop mcu
    StopMCU();
    printk("nFMode = %x\n", nFMode);
    if (nFMode == MUTUAL_SINE)
    	Msg28xxOpenSineModeSetting();
    else
    	Msg28xxOpenSwcapModeSetting();

    numKey = ptMutualMpTest->sensorInfo.numKey;

    if (MAX(numKey, 3) > 3)
    	numKey = 3;
    if (ptMutualMpTest->Mutual_Key != 0) {

    	u16 fmodeKey;
    	if (nFMode == MUTUAL_SINE)
    		fmodeKey = MUTUAL_SINE_KEY;
    	else
    	    fmodeKey = MUTUAL_KEY;

     	keyArray = (int *)kcalloc(numKey, sizeof(int), GFP_KERNEL);

    	if (ObtainOpenValue_VA_FW_v1007() < 0) {
    		printk("*** ObtainOpenValue_VA failed ***\n");
    	    if (keyArray != NULL)
    	    	kfree(keyArray);
    	    return -1;
    	}

    	if (nFMode == MUTUAL_SINE)
    	    Msg28xxOpenSineModeSetting();
    	else
    	   	Msg28xxOpenSwcapModeSetting();

    	if (Msg28xxReEnterMutualMode(fmodeKey) < 0) {
    		printk("*** Msg28xxReEnterMutualMode failed ***\n");
    	    if (keyArray != NULL)
    	    	kfree(keyArray);
    	    	return -1;
    	}

    	if (Msg28xxObtainOpenValue_Keys_FW_v1007(keyArray) < 0) {
    		printk("*** Msg28xxObtainOpenValue_Keys failed ***\n");
    	    if (keyArray != NULL)
    	    	kfree(keyArray);
    	    	return -1;
    	}

    	for (k = 0; k < numKey; k++) {
    		shift = (ptMutualMpTest->KeySen[k] - 1) * ptMutualMpTest->sensorInfo.KeyDrv_o + ptMutualMpTest->sensorInfo.KeyDrv_o - 1;
    		_gDeltaC[shift] = keyArray[k];
    	}
    } else {
    	if(Msg28xxGetDeltaC(_gDeltaC) < 0)	{
    		printk("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
    		if (keyArray != NULL)
    			kfree(keyArray);
    		return -1;
    	}
    }
    if (keyArray != NULL) {
    	printk("*** free keyArray ***\n");
    	kfree(keyArray);
    }
    return 0;
}

s32 Msg28xxopen_previous_FW_v1007(u16 nFMode)
{
    int *keyArray = NULL, k, numKey;
    u16 shift = 0;

    printk("*** %s() ***\n", __func__);

    // Stop mcu
    StopMCU();

    numKey = ptMutualMpTest->sensorInfo.numKey;

    if (MAX(numKey, 3) > 3)
    	numKey = 3;
    if (ptMutualMpTest->Mutual_Key != 0) {

    	if (ptMutualMpTest->Open_mode == 2) {
    		if(Msg28xxopen_latter_FW_v1007(nFMode) < 0) {
    			printk("*** Msg28xx Open Test# OpenTest failed! ***\n");
    		    return -1;
    		}
    	}
    	else {
    		if ((ptMutualMpTest->Pattern_type == 5) && (ptMutualMpTest->Pattern_model == 1)) {
    			if (nFMode == MUTUAL_SINE)
    				Msg28xxOpenSineModeSetting();
    			else
    				Msg28xxOpenSwcapModeSetting();

    			keyArray = (int *)kcalloc(numKey, sizeof(int), GFP_KERNEL);
    			if (ObtainOpenValue_VA() < 0) {
    				printk("*** ObtainOpenValue_VA failed ***\n");
    				if (keyArray != NULL)
    					kfree(keyArray);
    				return -1;
    			}

    			if (Msg28xxReEnterMutualMode(nFMode) < 0) {
    				printk("*** Msg28xxReEnterMutualMode failed ***\n");
    				if (keyArray != NULL)
    					kfree(keyArray);
    				return -1;
    			}

    			if (nFMode == MUTUAL_SINE)
    				Msg28xxOpenSineModeSetting();
    			else
    				Msg28xxOpenSwcapModeSetting();

    			if (Msg28xxObtainOpenValue_Keys(keyArray) < 0) {
    				printk("*** Msg28xxObtainOpenValue_Keys failed ***\n");
    				if (keyArray != NULL)
    					kfree(keyArray);
    				return -1;
    			}

    			for (k = 0; k < numKey; k++) {
    				shift = (ptMutualMpTest->KeySen[k] - 1) * ptMutualMpTest->sensorInfo.KeyDrv_o + ptMutualMpTest->sensorInfo.KeyDrv_o - 1;
    				_gDeltaC[shift] = keyArray[k];
    			}
    		}
    		else {
    			if (nFMode == MUTUAL_SINE)
    				Msg28xxOpenSineModeSetting();
    			else
    			   	Msg28xxOpenSwcapModeSetting();

    	    	if(Msg28xxGetDeltaC(_gDeltaC) < 0)	{
    	    		printk("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
    	    		if (keyArray != NULL)
    	    			kfree(keyArray);
    	    		return -1;
    	    	}
    		}
    	}
    } else {
		if (nFMode == MUTUAL_SINE)
			Msg28xxOpenSineModeSetting();
		else
		   	Msg28xxOpenSwcapModeSetting();

    	if(Msg28xxGetDeltaC(_gDeltaC) < 0)	{
    		printk("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
    		if (keyArray != NULL)
    			kfree(keyArray);
    		return -1;
    	}
    }
    if (keyArray != NULL) {
    	printk("*** free keyArray ***\n");
    	kfree(keyArray);
    }
    return 0;
}
    
u16 normalTestFail_check_Deltac[MAX_MUTUAL_NUM];
u16 normalTestFail_check_Ratio[MAX_MUTUAL_NUM];
#ifndef DISABLE_DOUBLE
double ratio_border[MAX_MUTUAL_NUM];
double ratio_move[MAX_MUTUAL_NUM];
double ratio_border_move[MAX_MUTUAL_NUM];
double ratio[MAX_MUTUAL_NUM];
#else
int ratio_border[MAX_MUTUAL_NUM];
int ratio_move[MAX_MUTUAL_NUM];
int ratio_border_move[MAX_MUTUAL_NUM];
int ratio[MAX_MUTUAL_NUM];
#endif

s32 Msg28xxOpenJudge(u16 nItemID, s8 *pNormalTestResult, u16 *pNormalTestResultCheck)
{
    s32 nRetVal = 0;
    u16 nCSub = 0;
    u16 nRowNum = 0, nColumnNum = 0;
    u16 i, j, k;
    u16 nCfb;
    s32 bg_per_csub = 0;
#ifndef DISABLE_DOUBLE
    double ratioAvg = 0.0, ratioAvg_max = 0.0, ratioAvg_min = 0.0, passCount = 0.0;
    double ratioAvg_border = 0.0, ratioAvg_border_max = 0.0, ratioAvg_border_min = 0.0, passCount1 = 0.0;
    double ratioAvg_move = 0.0, ratioAvg_border_move = 0.0;
#else
    int ratioAvg = 0, ratioAvg_max = 0, ratioAvg_min = 0, passCount = 0;
    int ratioAvg_border = 0, ratioAvg_border_max = 0, ratioAvg_border_min = 0, passCount1 = 0;
    int ratioAvg_move = 0, ratioAvg_border_move = 0;
#endif

    nCSub = ptMutualMpTest->Open_test_csub;
    
    printk("*** %s() ***\n", __func__);

    if ((ptMutualMpTest->Open_mode == 1) || (ptMutualMpTest->Open_mode == 2))// if open mode = 1 (sine mode), Csub must be zero.
    	nCSub = 0;

    if (!ptMutualMpTest->Open_test_cfb)
    	nCfb = 2;
    else
    	nCfb = ptMutualMpTest->Open_test_cfb;
#ifndef DISABLE_DOUBLE
        bg_per_csub = (int)(2.4 * 1.17 * 32768 / (11 * nCfb));
#else
        bg_per_csub = (int)(92012 / (11 * nCfb));
#endif
    for (i = 0; i < _gSenseLineNum * _gDriveLineNum; i++)
    {
        if (_gDeltaC[i] > 31000)
        {
            return -1;
        }
        if (_gDeltaC[i] != UN_USE_SENSOR)
        {
        	if (ptMutualMpTest->Pattern_type == 5)
        		_gResult[i] = bg_per_csub * nCSub - _gDeltaC[i];
        	else
        	   	_gResult[i] = 1673 * nCSub - _gDeltaC[i];
        }
        else
        	_gResult[i] = NULL_DATA;
        //For mutual key, last column if not be used, show number "one".
        if ((ptMutualMpTest->Mutual_Key == 1 || ptMutualMpTest->Mutual_Key == 2) && (ptMutualMpTest->sensorInfo.numKey != 0))
        {
        	if (ptMutualMpTest->Pattern_type == 5)
        	{
        		// KEY_CH = 1, it mean keys in same drive. Current one key project only KEY_CH = 1 type.
        		if (ptMutualMpTest->sensorInfo.KEY_CH != ptMutualMpTest->sensorInfo.numKey)
        		{
        			if (!((i + 1) % ptMutualMpTest->sensorInfo.numDrv))
        			{
        				_gResult[i] = NULL_DATA;
        				for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++)
        					if ((i + 1) / _gDriveLineNum == ptMutualMpTest->KeySen[k])
        					{
        						if (ptMutualMpTest->Pattern_model == 1)
        							_gResult[i] = bg_per_csub * nCSub - _gDeltaC[i];
        						else
        							_gResult[i] = 1673 * nCSub - _gDeltaC[i];
        					}
        			}
        		}
        		else
        		{
        			if (i > ((ptMutualMpTest->sensorInfo.numSen - 1) * ptMutualMpTest->sensorInfo.numDrv - 1))
        			{
        				_gResult[i] = NULL_DATA;
        				for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++)
        					if (((i + 1) - (_gSenseLineNum - 1) * _gDriveLineNum) == ptMutualMpTest->KeySen[k])
        				    {
        						if (ptMutualMpTest->Pattern_model == 1)
        							_gResult[i] = bg_per_csub * nCSub - _gDeltaC[i];
        						else
        				        	_gResult[i] = 1673 * nCSub - _gDeltaC[i];
        				    }
        			}
        		}
        	}
        	else
        	{
        		if ((_gSenseLineNum < _gDriveLineNum) && ((i + 1) % _gDriveLineNum == 0))
        		{
        			_gResult[i] = NULL_DATA;
        			for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++)
        				if ((i + 1) / _gDriveLineNum == ptMutualMpTest->KeySen[k])
        				{
        					_gResult[i] = 1673 * nCSub - _gDeltaC[i];
        				}
        		}

        		if ((_gSenseLineNum > _gDriveLineNum) && (i > (_gSenseLineNum - 1) * _gDriveLineNum - 1))
        		{
        			_gResult[i] = NULL_DATA;
        			for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++)
        			{
        				if (((i + 1) - (_gSenseLineNum - 1) * _gDriveLineNum) == ptMutualMpTest->KeySen[k])
        				{
        					_gResult[i] = 1673 * nCSub - _gDeltaC[i];
        				}
        			} //  for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++)
        		} // if ((_gSenseLineNum > _gDriveLineNum) && (i > (_gSenseLineNum - 1) * _gDriveLineNum - 1))
        	}
        }
    }
//     /// golden
//     /// checking golden + ratio

    memset(normalTestFail_check_Deltac, 0xFFFF, sizeof(normalTestFail_check_Deltac));
    memset(normalTestFail_check_Ratio, 0xFFFF, sizeof(normalTestFail_check_Ratio));
    memset(ratio,0,sizeof(ratio));
    memset(ratio_border,0,sizeof(ratio_border));
    memset(ratio_move,0,sizeof(ratio_move));
    memset(ratio_border_move,0,sizeof(ratio_move));

    nRowNum = _gDriveLineNum;
    nColumnNum = _gSenseLineNum;

    printk("*** Msg28xx Open Test# Show _gResult ***\n");
    DebugShowArray2(_gResult, nRowNum*nColumnNum, -32, 10, nColumnNum);	// debug sign 32 decimal value array
    printk("*** Msg28xx Open Test# Show Goldensample ***\n");
    DebugShowArray2(ptMutualMpTest->Goldensample_CH_0, nRowNum*nColumnNum, -32, 10, nColumnNum);
    for (k = 0; k < (sizeof(_gDeltaC) / sizeof(_gDeltaC[0])); k++)
    {
    	if (0 == ptMutualMpTest->Goldensample_CH_0[k]) {
    		if (k == 0)
    			pNormalTestResult[0] = 1;	// no golden sample
    		break;
    	}

    	if (_gResult[k] != NULL_DATA)
    	{
    		ratio[k] = (_gResult[k] * 1000) / ptMutualMpTest->Goldensample_CH_0[k];

    		if (0 == CheckValueInRange(_gResult[k], ptMutualMpTest->Goldensample_CH_0_Max[k], ptMutualMpTest->Goldensample_CH_0_Min[k]))
    		{
    			pNormalTestResult[0] = 1;
    			pNormalTestResultCheck[k] = (u16)(((k / _gDriveLineNum) + 1) * 100 + ((k % _gDriveLineNum) + 1));
    		}
    		else
    		{
    			pNormalTestResultCheck[k] = PIN_NO_ERROR;
    			if ((ptMutualMpTest->Pattern_type == 3) && (ptMutualMpTest->sensorInfo.numKey == 0) && ((k % _gDriveLineNum == 0 )||((k + 1) % _gDriveLineNum == 0)))
    			{
    				ratioAvg_border += ratio[k];
    				passCount1 += 1;
    			}
    			else if ((ptMutualMpTest->Pattern_type == 3) && (ptMutualMpTest->sensorInfo.numKey != 0) && ((k % _gDriveLineNum == 0) || ((k + 2) % _gDriveLineNum == 0)))
    			{
    				ratioAvg_border += ratio[k];
    				passCount1 += 1;
    			}
    			else
    			{
    				ratioAvg += ratio[k];
    				passCount += 1;
    			}
    		}
    	}
    	else
    	{
    		pNormalTestResultCheck[k] = PIN_NO_ERROR;
    	}
    	normalTestFail_check_Deltac[k] = pNormalTestResultCheck[k];
    }
    //DEBUG("*** Msg28xx Open Test# normalTestFail_check_Deltac Channel ***\n");
    //DebugShowArray2(normalTestFail_check_Deltac, nRowNum*nColumnNum, 16, 16, nColumnNum);	// debug sign 32 decimal value array
#ifndef DISABLE_DOUBLE
    ratioAvg_max = (double)(100 + ptMutualMpTest->ToastInfo.persentDC_VA_Ratio + ptMutualMpTest->ToastInfo.persentDC_VA_Ratio_up) / 100.0;
    ratioAvg_min = (double)(100 - ptMutualMpTest->ToastInfo.persentDC_VA_Ratio) / 100.0;

    ratioAvg_border_max=(double)(100 + ptMutualMpTest->ToastInfo.persentDC_Border_Ratio + ptMutualMpTest->ToastInfo.persentDC_VA_Ratio_up) / 100.0;
    ratioAvg_border_min = (double)(100 - ptMutualMpTest->ToastInfo.persentDC_Border_Ratio) / 100.0;
#else
    ratioAvg_max = (int)(100000 + (ptMutualMpTest->ToastInfo.persentDC_VA_Ratio * 1000) + (ptMutualMpTest->ToastInfo.persentDC_VA_Ratio_up * 1000)) / 100;
    ratioAvg_min = (int)(100000 - (ptMutualMpTest->ToastInfo.persentDC_VA_Ratio * 1000)) / 100;

    ratioAvg_border_max=(int)(100000 + (ptMutualMpTest->ToastInfo.persentDC_Border_Ratio * 1000) + (ptMutualMpTest->ToastInfo.persentDC_VA_Ratio_up * 1000)) / 100;
    ratioAvg_border_min = (int)(100000 - (ptMutualMpTest->ToastInfo.persentDC_Border_Ratio * 1000)) / 100;
#endif

    if (passCount != 0)
    {
        if (passCount1 != 0)
        {
            ratioAvg_border_move = ratioAvg_border / passCount1;

            ratioAvg_move = ratioAvg / passCount;

            for (i = 0; i < sizeof(ratio) / sizeof(ratio[0]); i++)
            {
                if ((ptMutualMpTest->sensorInfo.numKey == 0) && ((i % _gDriveLineNum == 0) || ((i + 1) % _gDriveLineNum == 0)))
                {
                    ratio_move[i] = ratio[i] - ratioAvg_border_move + 1;
                }
                else if ((ptMutualMpTest->sensorInfo.numKey != 0) && ((i % _gDriveLineNum == 0) || ((i + 2) % _gDriveLineNum == 0)))
                {
                    ratio_move[i] = ratio[i] - ratioAvg_border_move + 1;
                }
                else
                {
                    ratio_move[i] = ratio[i] - ratioAvg_move + 1;
                }

            }
        }
        else
        {
            ratioAvg_move = ratioAvg / passCount;

            for (i = 0; i < sizeof(ratio) / sizeof(ratio[0]); i++)
            {
               ratio_move[i] = ratio[i] - ratioAvg_move + 1000;
            }
        }
    }
    else
    {
        memcpy(ratio,ratio_move,sizeof(ratio));
    }
    for (j = 0; j < (sizeof(_gDeltaC) / sizeof(_gDeltaC[0])); j++)
    {
        if (0 == ptMutualMpTest->Goldensample_CH_0[j]) {
        	if (j == 0)
        		pNormalTestResult[1] = 1;	// no golden sample
        	break;
        }

        if (PIN_NO_ERROR == pNormalTestResultCheck[j])
        {
            if (_gResult[j] != NULL_DATA)
            {
                if ((ptMutualMpTest->Pattern_type == 3) && (ptMutualMpTest->sensorInfo.numKey == 0) && ((j % _gDriveLineNum == 0) || ((j + 1) % _gDriveLineNum == 0)))
                {
                    if (0 == checkDoubleValueInRange(ratio_move[j], ratioAvg_border_max, ratioAvg_border_min))
                    {
                    	pNormalTestResult[1] = 1;
                    	pNormalTestResultCheck[j] = (u16)(((j / _gDriveLineNum) + 1) * 100 + ((j % _gDriveLineNum) + 1));
                    }
                    else
                    {
                    	pNormalTestResultCheck[j] = PIN_NO_ERROR;
                    }
                }
                else if ((ptMutualMpTest->Pattern_type == 3) && (ptMutualMpTest->sensorInfo.numKey != 0) && ((j % _gDriveLineNum == 0) || ((j + 2) % _gDriveLineNum == 0)))
                {
                    if (0 == checkDoubleValueInRange(ratio_move[j], ratioAvg_border_max, ratioAvg_border_min))
                    {
                    	pNormalTestResult[1] = 1;
                    	pNormalTestResultCheck[j] = (u16)(((j / _gDriveLineNum) + 1) * 100 + ((j % _gDriveLineNum) + 1));
                    }
                    else
                    {
                    	pNormalTestResultCheck[j] = PIN_NO_ERROR;
                    }
                }
                else
                {
                	//DEBUG("ratiomove[%d] = %f, ratioAvg_max = %f, ratioAvg_min = %f",j,ratio_move[j], ratioAvg_max, ratioAvg_min);
                    if (0 == checkDoubleValueInRange(ratio_move[j], ratioAvg_max, ratioAvg_min))
                    {
                    	pNormalTestResult[1] = 1;
                    	pNormalTestResultCheck[j] = (u16)(((j / _gDriveLineNum) + 1) * 100 + ((j % _gDriveLineNum) + 1));
                    }
                    else
                    {
                    	pNormalTestResultCheck[j] = PIN_NO_ERROR;
                    }
                }
            }
            else
            {
            	pNormalTestResultCheck[j] = PIN_NO_ERROR;
            }
        }
        else
        {
            normalTestFail_check_Ratio[j] = pNormalTestResultCheck[j];
            continue;
        }
        normalTestFail_check_Ratio[j] = pNormalTestResultCheck[j];
    }

    //DEBUG("*** Msg28xx Open Test# normalTestFail_check_Ratio Channel ***\n");
    //DebugShowArray2(normalTestFail_check_Ratio, nRowNum*nColumnNum, 16, 16, nColumnNum);	// debug sign 32 decimal value array
    for (k = 0; k < MAX_MUTUAL_NUM; k++)
    {
        if (0 == ptMutualMpTest->Goldensample_CH_0[k])
        {
        	pNormalTestResultCheck[k] = PIN_NO_ERROR;
            normalTestFail_check_Deltac[k] = PIN_NO_ERROR;
            normalTestFail_check_Ratio[k] = PIN_NO_ERROR;
        }
        else
        {
            continue;
        }
    }

    if ((pNormalTestResult[0] != 0) || (pNormalTestResult[1] != 0))
    	nRetVal = -1;

    for (i = 0; i < 2; i++)
    {
    	ptMutualMpTestResult->pCheck_Fail[i] = pNormalTestResult[i];
    }

    for (i = 0; i < sizeof(normalTestFail_check_Deltac) / sizeof(normalTestFail_check_Deltac[0]); i++)	// reduce memory operation instead of memcpy
    {
    	ptMutualMpTestResult->pOpenFailChannel[i] = normalTestFail_check_Deltac[i];
    	ptMutualMpTestResult->pOpenRatioFailChannel[i] = normalTestFail_check_Ratio[i];
    	ptMutualMpTestResult->pGolden_CH_Max_Avg[i] = ratio_move[i];
    }

    return nRetVal;
}

s8 nNormalTestResult[2] = {0};    //0:golden    1:ratio
u16 nNormalTestResultCheck[MAX_MUTUAL_NUM] = {0};        //6:max subframe    13:max afe

int Msg28xxOpenTestEntry(u16 fw_ver)
{
	u16 fmode = MUTUAL_MODE, i;
    s32 nRetVal = 0;

    u8 time = 0;    
    u16 nScanMode = 0;
    u16 deep_standby = 0;

    printk("*** %s() ***\n", __func__);

    deep_standby = ptMutualMpTest->deep_standby;
    _gSenseLineNum = ptMutualMpTest->sensorInfo.numSen;
    _gDriveLineNum = ptMutualMpTest->sensorInfo.numDrv;
    _gResult = ptMutualMpTestResult->pOpenResultData;
    
    //_gTestFailChannel = ptMutualMpTestResult->pOpenFailChannel;

    //DisableFingerTouch();
    DrvDisableFingerTouchReport();

_retry_open:

    //TouchDeviceResetHw();
    DrvTouchDeviceHwReset();

    EnterDBBus();
    //usleep(100000);
    mdelay(100);

    // Stop mcu
    StopMCU();

    printk("** nDriOpening = %d \n", RegGetLByteValue(0x1312));

    switch (ptMutualMpTest->Open_mode) {
    	case 0:
    		fmode = MUTUAL_MODE;
    		break;
    	case 1:
    	case 2:
    		fmode = MUTUAL_SINE;
    		break;
    }

    if(Msg28xxSwitchFwMode(&fmode, &deep_standby) < 0)
    {
        printk("*** Msg28xx Open Test# SwitchFwMode failed! ***\n");
        time++;
        if (time < 10)
        	goto _retry_open;
        else {
        	for (i = 0; i < 2; i++)
            {
                ptMutualMpTestResult->pCheck_Fail[i] = 1;
            }
            for (i = 0; i < MAX_MUTUAL_NUM; i++)	// reduce memory operation instead of memcpy
            {
                ptMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
                ptMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
            }
            nRetVal = -1;
        	goto ITO_TEST_END;
        }
    }

    nScanMode = RegGet16BitValueByAddressMode(0x136E, ADDRESS_MODE_16BIT);

    if (fw_ver == 0x0007) {
    	if ((nScanMode != KEY_SEPERATE) && (nScanMode != KEY_COMBINE))
    		nScanMode = KEY_SEPERATE;
    }
    else if (fw_ver < 0x0007){
    	nScanMode = KEY_COMBINE;
    }

    if (nScanMode == KEY_SEPERATE) {
    	printk("fmode = %x \n", fmode);
    	if(Msg28xxopen_latter_FW_v1007(fmode) < 0) {
    		printk("*** Msg28xx Open Test# OpenTest failed! ***\n");
    		for (i = 0; i < 2; i++)
            {
                ptMutualMpTestResult->pCheck_Fail[i] = 1;
            }
            for (i = 0; i < MAX_MUTUAL_NUM; i++)	// reduce memory operation instead of memcpy
            {
                ptMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
                ptMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
            }
    		nRetVal = -1;
    		goto ITO_TEST_END;
    	}
    }
    else {
    	printk("fmode = %x", fmode);
    	if(Msg28xxopen_previous_FW_v1007(fmode) < 0) {
    	//if(Msg28xxopen_latter_FW_v1007(fmode) < 0) {
    		printk("*** Msg28xx Open Test# OpenTest failed! ***\n");
    		for (i = 0; i < 2; i++)
            {
                ptMutualMpTestResult->pCheck_Fail[i] = 1;
            }
            for (i = 0; i < MAX_MUTUAL_NUM; i++)	// reduce memory operation instead of memcpy
            {
                ptMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
                ptMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
            }
    	    nRetVal = -1;
    	    goto ITO_TEST_END;
    	}
    }

    //usleep(10000);
    mdelay(10);

    nRetVal = Msg28xxOpenJudge(0, nNormalTestResult, nNormalTestResultCheck);
    printk("*** Msg28xx Open Test# OpenTestOpenJudge return value = %d ***\n", nRetVal);

    ExitDBBus();

ITO_TEST_END:

    //TouchDeviceResetHw();
    DrvTouchDeviceHwReset();
    //usleep(300000);
    mdelay(300);
    //EnableFingerTouch();
    DrvEnableFingerTouchReport();

    return nRetVal;
}

int Msg28xxOpenTest(u16 fw_ver)
{
    int nRetVal = 0;
    int nRet = 0;

    nRetVal = Msg28xxOpenTestEntry(fw_ver);
    if (nRetVal == 0){
    	nRet = ITO_TEST_OK; //PASS
        printk("Msg28xx Open Test# MP test success\n");
    }else{
    	if(nRetVal == -1){
    	    nRet = ITO_TEST_FAIL;
        }
        else if (nRetVal == -2){
            nRet = ITO_TEST_GET_TP_TYPE_ERROR;
        }
        else{
            nRet = ITO_TEST_UNDEFINED_ERROR;
        }

        printk("Msg28xx Open Test# MP test failed\n");
    }

    return nRet;
}