/*
 * Copyright (C) 2006-2017 ILITEK TECHNOLOGY CORP.
 *
 * Description: ILITEK I2C touchscreen driver for linux platform.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see the file COPYING, or write
 * to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 * Author: Dicky Chiang
 * Maintain: Luca Hsu, Tigers Huang
 */
 
#include "OpenTest.h"

int _gMsg30xxDeltaC[MAX_MUTUAL_NUM] = {0};
int _gMsg30xxDeltaCVA[MAX_MUTUAL_NUM] = {0};
int * _gResult_msg30xx;
int _gMsg30xxSenseLineNum = 0;
int _gMsg30xxDriveLineNum = 0;
int _gMsg30xxWaterProofNum = 0;

extern u32 SLAVE_I2C_ID_DBBUS; //0x62 // for MSG28xx/MSG58xxA/ILI2117A/ILI2118A
extern u32 SLAVE_I2C_ID_DWI2C; //0x26

void Msg30xxSetCfb(u8 Cfb)  //201703xx
{
	printk("*** %s() ***\n", __func__);

	/// Setting Cfb
	switch (Cfb)
	{
		case _Msg30xx50p: /// Cfb = 50p
			RegMask16BitValue(0x1528, (u16)0x0070, (u16)0x0000, ADDRESS_MODE_16BIT);
			RegMask16BitValue(0x1523, (u16)0x0700, (u16)0x0000, ADDRESS_MODE_16BIT);	/// 0x1523[10:8] = 0x0, Rfb: 180kohm
	        break;
	    case _Msg30xx45p: /// Cfb = 45p
	    	RegMask16BitValue(0x1528, (u16)0x0070, (u16)0x0010, ADDRESS_MODE_16BIT);
	    	RegMask16BitValue(0x1523, (u16)0x0700, BIT8, ADDRESS_MODE_16BIT);	/// 0x1523[10:8] = 0x1, Rfb: 225kohm
	        break;
	    case _Msg30xx35p: /// Cfb = 35p
	    	RegMask16BitValue(0x1528, (u16)0x0070, (u16)0x0020, ADDRESS_MODE_16BIT);
	    	RegMask16BitValue(0x1523, (u16)0x0700, BIT9, ADDRESS_MODE_16BIT);	/// 0x1523[10:8] = 0x2, Rfb: 300kohm
	    	break;
	    case _Msg30xx30p: /// Cfb = 30p
	    	RegMask16BitValue(0x1528, (u16)0x0070, (u16)0x0040, ADDRESS_MODE_16BIT);
	    	RegMask16BitValue(0x1523, (u16)0x0700, BIT9, ADDRESS_MODE_16BIT);	/// 0x1523[10:8] = 0x2, Rfb: 300kohm
	        break;
	    case _Msg30xx25p: /// Cfb = 25p
	    	RegMask16BitValue(0x1528, (u16)0x0070, (u16)0x0050, ADDRESS_MODE_16BIT);
	    	RegMask16BitValue(0x1523, (u16)0x0700, BIT9, ADDRESS_MODE_16BIT);	/// 0x1523[10:8] = 0x2, Rfb: 300kohm
	        break;
	    default:
	        break;
	}

}

void Msg30xxCalibrateMutualCsub(s16 nCSub)
{
    printk("*** %s() ***\n", __func__);

    Msg30xxSetMutualCsubViaDBbus(nCSub);
}

u16 Msg30xxAnaGetMutualChannelnum(void)
{
    printk("*** %s() ***\n", __func__);
    return (RegGet16BitValue(0x102E) & (BIT0 | BIT1 | BIT2 | BIT3));
}

u16 Msg30xxAnaGetMutualSubframenum(void)
{
    printk("*** %s() ***\n", __func__);
    return ((RegGet16BitValue(0x1216) & (BIT8 | BIT9 | BIT10 | BIT11 | BIT12 | BIT13 | BIT14 | BIT15)) >> 8) + 1;
}

void Msg30xxUpdateAnaChargeDumpSetting(void)
{
    printk("*** %s() ***\n", __func__);
    RegSet16BitValueByAddressMode(0x1018, 0x001F, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x1019, 0x003f, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x101a, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub0
    RegSet16BitValueByAddressMode(0x101b, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub1
    RegSet16BitValueByAddressMode(0x101c, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub2
    RegSet16BitValueByAddressMode(0x101d, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub3
    RegSet16BitValueByAddressMode(0x101e, 0x0028, ADDRESS_MODE_16BIT);  //post idle time in sub4
    RegSet16BitValueByAddressMode(0x101f, 0x0000, ADDRESS_MODE_16BIT);

    RegSet16BitValueByAddressMode(0x100d, 0x0020, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x1103, 0x0020, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x1104, 0x0020, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x1302, 0x0020, ADDRESS_MODE_16BIT);
    RegSet16BitValueByAddressMode(0x136b, 0x10000 / 0x20, ADDRESS_MODE_16BIT);    // AFE_coef, set value by 0x10000 dividing register 0x100d value
    RegSet16BitValueByAddressMode(0x1b30, 0x0020, ADDRESS_MODE_16BIT);
}

s32 Msg30xxGetDeltaC(s32 *pDeltaC, u16 drv_mode)
{
    s16 * pRawData = NULL;
	//s16 pRawData[MAX_CHANNEL_SEN * 2 * MAX_CHANNEL_DRV];
	//s16 nRawDataOverlapDone[_gMsg30xxSenseLineNum][_gMsg30xxDriveLineNum];
	s16 **nRawDataOverlapDone = NULL;
    //s16 nDeltaC[MAX_MUTUAL_NUM] = {0};
    u16 nDrvPos = 0, nSenPos = 0, nShift = 0;
    u16 nSenNumBak = 0;
    u16 nDrvNumBak = 0;
    s16 i, j;

    printk("*** %s() ***\n", __func__);

    pRawData = (s16 *)kmalloc(sizeof(s16) * MAX_CHANNEL_SEN*2 * MAX_CHANNEL_DRV, GFP_KERNEL);
    nRawDataOverlapDone = (s16 **)kmalloc(_gMsg30xxSenseLineNum * sizeof(void *), GFP_KERNEL);
    for (i = 0; i < _gMsg30xxSenseLineNum; ++i)
    {
    	nRawDataOverlapDone[i] = (s16 *)kmalloc(_gMsg30xxDriveLineNum * sizeof(s16), GFP_KERNEL);
    }

    memset(pRawData, 0, sizeof(*pRawData));
    memset(nRawDataOverlapDone, 0, sizeof(**nRawDataOverlapDone));

    if(Msg30xxGetMutualOneShotRawIIR(pRawData, &nSenNumBak, &nDrvNumBak, drv_mode) < 0)
    {
        printk("*** Msg30xx Open Test# GetMutualOneShotRawIIR failed! ***\n");
        return -1;
    }

    printk("*** Msg30xx Open Test# nSenNumBak=%d nDrvNumBak=%d ***\n", nSenNumBak, nDrvNumBak);

    for (i = 0; i < _gMsg30xxSenseLineNum; i++)
    {
    	for (j = 0; j < _gMsg30xxDriveLineNum; j++)
    	{
    		nRawDataOverlapDone[i][j] = UN_USE_SENSOR;
    	}
    }
    for (i = 0; i < nSenNumBak; i++)
    {
        for (j = 0; j < nDrvNumBak; j++)
        {
            nShift = (u16)(i * nDrvNumBak + j);

            nDrvPos = ptMsg30xxMutualMpTest->sensorInfo.mapping[nShift].Y;
            nSenPos = ptMsg30xxMutualMpTest->sensorInfo.mapping[nShift].X;

            if (nDrvPos >= _gMsg30xxDriveLineNum || nSenPos >= _gMsg30xxSenseLineNum) continue;

            if (nDrvPos != 0xFF && nSenPos != 0xFF)
            {
            	//printk("*** Msg30xx Open Test# Transfer get nRawDataOverlapDone nDrvPos = %d, nSenPos = %d, nShift = %d", nDrvPos, nSenPos,nShift);
                nRawDataOverlapDone[nSenPos][nDrvPos] = pRawData[i*MAX_CHANNEL_DRV+j];
            }
        }
    }

    //printk("*** Msg30xx Open Test# Transfer nRawDataOverlapDone to pDeltaC");
    for (i = 0; i < _gMsg30xxSenseLineNum; i++)
    {
        for (j = 0; j < _gMsg30xxDriveLineNum; j++)
        {
            nShift = (u16)(i * _gMsg30xxDriveLineNum + j);
            pDeltaC[nShift] = (s32)nRawDataOverlapDone[i][j];
        }
    }

    printk("*** Msg30xx Open Test# gDeltaC ***\n");
    DebugShowArray2(pDeltaC, _gMsg30xxSenseLineNum * _gMsg30xxDriveLineNum, -32, 10, _gMsg30xxSenseLineNum);
    kfree(pRawData);
    kfree(nRawDataOverlapDone);
    return 0;
}

void _Msg30xxHalSramEnterAccessMode(void)
{
    printk("*** %s() ***\n", __func__);
	// change to R2 mode
	RegMask16BitValue(0x2140, BIT8, BIT8, ADDRESS_MODE_16BIT);
    // SRAM using MCU clock
	RegMask16BitValue(0x1E11, BIT13, BIT13, ADDRESS_MODE_16BIT);
}

void _Msg30xxHalSramExitAccessMode(void)
{
	printk("*** %s() ***\n", __func__);
	// change to R2 mode
	RegMask16BitValue(0x2140, BIT8, 0, ADDRESS_MODE_16BIT);
	// SRAM using MCU clock
	RegMask16BitValue(0x1E11, BIT13, 0, ADDRESS_MODE_16BIT);
}

void _Msg30xxWriteDQMem_8bit(u16 addr, u8 data)
{
	u8 read_buf[4] = {0};
    u16 high_16, low_16 = 0;
    u16 read_addr = 0;

    printk("*** %s() ***\n", __func__);

    read_addr = addr - (addr % 4);

    RegGet16BitByteValueBuf(read_addr, read_buf, sizeof(read_buf) / sizeof(read_buf[0]));

    read_buf[addr % 4] = data;
    printk("read_buf:0x%02x 0x%02x 0x%02x  0x%02x", read_buf[0], read_buf[1], read_buf[2], read_buf[3]);
    low_16 = (((u16)read_buf[1] << 8) | read_buf[0]);
    high_16 = (((u16)read_buf[3] << 8) | read_buf[2]);

    RegSet16BitValue(read_addr + 2, low_16);
    RegSet16BitValue(read_addr, high_16);
}

void _Msg30xxWriteDQMem_32bits(u16 addr, u32 data)
{
    u8 read_buf[4] = {0};
    u16 high_16, low_16 = 0;
    u16 read_addr = 0;

    printk("*** %s() ***\n", __func__);

    read_addr = addr - (addr % 4);

    RegGet16BitByteValueBuf(read_addr, read_buf, sizeof(read_buf) / sizeof(read_buf[0]));
    printk("read_buf[0] = 0x%02X, read_buf[1] = 0x%02X, read_buf[2] = 0x%02X, read_buf[3] = 0x%02X", read_buf[0], read_buf[1], read_buf[2], read_buf[3]);

    low_16 = (data & 0xFFFF);
    high_16 = (data >> 16);
    RegSet16BitValue(read_addr + 2, low_16);
    RegSet16BitValue(read_addr, high_16);
    RegGet16BitByteValueBuf(read_addr, read_buf, sizeof(read_buf) / sizeof(read_buf[0]));
    printk("read_buf[0] = 0x%02X, read_buf[1] = 0x%02X, read_buf[2] = 0x%02X, read_buf[3] = 0x%02X", read_buf[0], read_buf[1], read_buf[2], read_buf[3]);
}

s32 Msg30xxObtainOpenValue_Keys_FW_v1007(s32 *pkeyarray)
{
	s32 k;
	//s32 i, isf = 0;
	//u8 u8ShotData[16];
	//u16 nSf = ptMsg30xxMutualMpTest->sub_frame;
	//u8 nRegData = 0;
	//u16 addr = 0x6410;
	//u16 keySen = ptMsg30xxMutualMpTest->PAD2Drive[ptMsg30xxMutualMpTest->sensorInfo.KeyDrv_o - 1];
	u16 drv_mode = 0;
    u16 numKey = 0;

	printk("*** %s() ***\n", __func__);

	if (Msg30xxGetDeltaC(_gMsg30xxDeltaCVA, drv_mode) < 0) {
		printk("*** Msg30xx Open Test# GetDeltaC failed! ***\n");
	    return -1;
	}

	numKey = ptMsg30xxMutualMpTest->sensorInfo.numKey;

	if (MAX(numKey, 3) > 3)
	    numKey = 3;

	for (k = 0; k < numKey; k++) {
		pkeyarray[k] = _gMsg30xxDeltaCVA[k];
	}
	return 0;
}

s32 Msg30xxObtainOpenValue_Keys(s32 *pkeyarray)
{
	s32 k;
	u16 drv_mode = 0, numKey, drvNum, senNum;
	u32 shift = 0;

	printk("*** %s() ***\n", __func__);

	if(Msg30xxGetDeltaC(_gMsg30xxDeltaCVA, drv_mode) < 0) {
		printk("*** Msg30xx Open Test# GetDeltaC failed! ***\n");
	    return -1;
	}
	numKey = ptMsg30xxMutualMpTest->sensorInfo.numKey;
	drvNum = ptMsg30xxMutualMpTest->sensorInfo.numDrv;
	senNum = ptMsg30xxMutualMpTest->sensorInfo.numSen;
	if (MAX(numKey, 3) > 3)
	    numKey = 3;

	for (k = 0; k < numKey; k++) {
		shift = (ptMsg30xxMutualMpTest->KeySen[k] - 1) * ptMsg30xxMutualMpTest->sensorInfo.KeyDrv_o + ptMsg30xxMutualMpTest->sensorInfo.KeyDrv_o - 1;
		pkeyarray[k] = _gMsg30xxDeltaCVA[shift];
	}
	return 0;
}

s32 Msg30xxObtainOpenValue_VA_FW_v1007(void)
{
    u16 drv_mode = 0;
	if(Msg30xxGetDeltaC(_gMsg30xxDeltaC, drv_mode) < 0)	{
		printk("*** Msg30xx Open Test# GetDeltaC failed! ***\n");
		return -1;
	}
	return 0;
}

s32 Msg30xxObtainOpenValue_VA(void)
{
	s32 baseLen = 6, byteLen = 8, index = 0;
    u8 u8DrvData = 0;
    u32 uRegData32bits[4] = {0};
    u8 u8ShotData[16] = {0};
    u16 i, isf, nSf = 0, afe_opening = 0, dri_opening = 0, nDataLen = 0;
	u16 keySen = ptMsg30xxMutualMpTest->PAD2Drive[ptMsg30xxMutualMpTest->sensorInfo.KeyDrv_o - 1];
	u16 drv_mode = 0, regdata = 0;
	s32 addr = 0;   /// base address of FW mutual drive mapping.

	printk("*** %s() ***\n", __func__);

	regdata = RegGet16BitValueByAddressMode(0x1305, ADDRESS_MODE_16BIT);
    nSf = (regdata & (BIT8 | BIT9 | BIT10 | BIT11 | BIT12 | BIT13) >> 8);
    afe_opening = regdata & (BIT0 | BIT1 | BIT2 | BIT3);

    dri_opening = Msg30xxGet_Drv_opening();
	_Msg30xxHalSramEnterAccessMode();
	for (isf = 0; isf < nSf; isf++) {
		memset(u8ShotData, 0, sizeof(u8ShotData));
		if (dri_opening == 17)
        {
            addr = 0x7000;
            nDataLen = 16;
            index = nDataLen - 1;
        }
        else
        {
            addr = 0x7010;
            nDataLen = dri_opening;
            index = 0;
        }
		Msg30xxDBBusReadDQMemStart();
		//RegGetXByteValue(u8ShotData, add + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0]));
        RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData) / sizeof(u8ShotData[0]), MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		DebugShowArray2(u8ShotData, 16, 16, 16, 16);
		// Find key index, then replace key sensor by assign sensor 56(0x38).
		for (i = 0; i < nDataLen; i++)
		{
		    uRegData32bits[i / 4] |= (u32)u8ShotData[i] << (byteLen * (i % 4));
		}
		printk("Check KeySen : %d\n", keySen);
		 for (i = index; i < nDataLen; i++)
		 {
			u8DrvData = (u8)((uRegData32bits[i / 4] >> (baseLen * (i % 4))) & 0x3F);
			printk("Driving PAD[%d] = %d\n", i, u8DrvData);
			if (u8DrvData == keySen)
			{
				uRegData32bits[i / 4] &= (u32)~(0x3F << (baseLen * (i % 4)));
                uRegData32bits[i / 4] |= (u32)(0x05 << (baseLen * (i % 4))); //need discuss fout appear abnormal if overwrite key drive, 0x05 pad is temporary, it must be changed
                _Msg30xxWriteDQMem_32bits(addr + isf * 0x20 + i, uRegData32bits[i / 4]);
			}
		}
		Msg30xxDBBusReadDQMemEnd();
		DebugShowArray2(u8ShotData, 16, 16, 16, 16);
	}
	_Msg30xxHalSramExitAccessMode();
	Msg30xxAnaSwReset();
	if(Msg30xxGetDeltaC(_gMsg30xxDeltaC, drv_mode) < 0)	{
		printk("*** Msg30xx Open Test# GetDeltaC failed! ***\n");
	    return -1;
	}
	printk("*** ObtainOpenValue_VA End ***\n");
	return 0;
}

s32 Msg30xxReEnterMutualMode(u16 nFMode)
{
    u16 nRegData = 0;

	printk("*** %s() ***\n", __func__);

	StartMCU();
	Msg30xxDBBusReEnter();
	mdelay(50);
	RegSet16BitValue(0x1402, nFMode);
	printk("nFMode = %x", nFMode);
	if (Msg30xxCheckSwitchStatus()<0) {
		printk("*** Msg30xx MP Test# CheckSwitchStatus failed! ***\n");
	    return -1;
	}
    nRegData = RegGet16BitValueByAddressMode(0x1361, ADDRESS_MODE_16BIT);
    _gMsg30xxfout_base_addr = (u16)(nRegData << 2);
    printk("_gMsg30xxfout_base_addr = 0x%04x\n", _gMsg30xxfout_base_addr);
	StopMCU();
	RegSet16BitValue(0x3D08, 0xFEFF);//open timer
	return 0;
}

void Msg30xxOpenSwcapModeSetting(void)
{
	u16 chargeT = ptMsg30xxMutualMpTest->OPEN_Charge, dumpT = ptMsg30xxMutualMpTest->OPEN_Dump;

    printk("*** %s() ***\n", __func__);

	// Stop mcu
	StopMCU();
    if (chargeT == 0 || dumpT == 0)
    {
        chargeT = 0x18;
        dumpT = 0x16;
    }
	Msg30xxCalibrateMutualCsub(ptMsg30xxMutualMpTest->Open_test_csub);
	Msg30xxGain_Setting();
	Msg30xxAnaChangeCDtime(chargeT, dumpT);
	Msg30xxAnaEnableChargePump(ptMsg30xxMutualMpTest->Open_test_chargepump);
	Msg30xxTgenOvwrROSSelect(ptMsg30xxMutualMpTest->Open_test_chargepump, ONE_DAC_ENABLE);
	Msg30xxTgenOvwrDRVLvBufGainSetting(ptMsg30xxMutualMpTest->Open_test_chargepump, ONE_DAC_ENABLE);
	Msg30xxTgenOvwrDRVLvBufCfbSetting(ptMsg30xxMutualMpTest->Open_test_chargepump, ONE_DAC_ENABLE);
	Msg30xxTgenOvwrInverterMode(ptMsg30xxMutualMpTest->inverter_mode, ONE_DAC_ENABLE);
	Msg30xxScanDacSetting(ONE_DAC_ENABLE);
	Msg30xxAnaSwReset();
}

void Msg30xxOpenSineModeSetting(void)
{
    u8 nCfb = 0;
	printk("*** %s() ***\n", __func__);

    Msg30xxTgenOvwrRegEn(ENABLE);
    Msg30xxAnaEnableChargePump(ptMsg30xxMutualMpTest->Open_test_chargepump);
    Msg30xxTgenOvwrROSSelect(ptMsg30xxMutualMpTest->Open_test_chargepump, _gMsg30xxTwoDACEnable);
    Msg30xxTgenOvwrDRVLvBufGainSetting(ptMsg30xxMutualMpTest->Open_test_chargepump, _gMsg30xxTwoDACEnable);
    Msg30xxTgenOvwrDRVLvBufCfbSetting(ptMsg30xxMutualMpTest->Open_test_chargepump, _gMsg30xxTwoDACEnable);
    Msg30xxTgenOvwrInverterMode(ptMsg30xxMutualMpTest->inverter_mode, _gMsg30xxTwoDACEnable);
    if (!ptMsg30xxMutualMpTest->inverter_mode)    // inverter mode == off must set DAC enable, otherwise it can't fetch fout
        Msg30xxScanDacSetting(_gMsg30xxTwoDACEnable);
    printk("Msg30xxSetCfb : %d, _gMsg30xxTwoDACEnable : %d", ptMsg30xxMutualMpTest->Open_test_cfb, _gMsg30xxTwoDACEnable);
	nCfb = ptMsg30xxMutualMpTest->Open_test_cfb;
	switch (ptMsg30xxMutualMpTest->Open_test_cfb) {
		case 0:
	    case 2:
	     	Msg30xxSetCfb(_Msg30xx30p);
	        break;
	    case 1:
	    	Msg30xxSetCfb(_Msg30xx25p);
	        break;
	    case 3:
	        Msg30xxSetCfb(_Msg30xx35p);
	        break;
	    case 4:
	        Msg30xxSetCfb(_Msg30xx45p);
	        break;
	    case 5:
	        Msg30xxSetCfb(_Msg30xx50p);
	        break;
	}
}

s32 Msg30xxopen_latter_FW_v1007(u16 nFMode)
{
    int *keyArray = NULL, k;
    u16 shift = 0;
    u16 drv_mode = 0;
    int numKey = 0;

    // Stop mcu
    StopMCU();
    printk("%s: nFMode = %x\n", __func__,nFMode);

    if (nFMode == MUTUAL_SINE)
    	Msg30xxOpenSineModeSetting();
    else
    	Msg30xxOpenSwcapModeSetting();

    numKey = ptMsg30xxMutualMpTest->sensorInfo.numKey;
    if (MAX(numKey, 3) > 3)
    	numKey = 3;
    if (ptMsg30xxMutualMpTest->Mutual_Key != 0) {

    	u16 fmodeKey;
    	if (nFMode == MUTUAL_SINE)
    		fmodeKey = MUTUAL_SINE_KEY;
    	else
    	    fmodeKey = MUTUAL_KEY;

     	keyArray = (int *)kcalloc(numKey, sizeof(int), GFP_KERNEL);

    	if (Msg30xxObtainOpenValue_VA_FW_v1007() < 0) {
    		printk("*** ObtainOpenValue_VA failed ***\n");
    	    if (keyArray != NULL)
    	    	kfree(keyArray);
    	    return -1;
    	}

    	if (ptMsg30xxMutualMpTest->Open_KeySettingByFW == 0)   // Use our MP setting.
        {

            if (nFMode == MUTUAL_SINE)
                Msg30xxOpenSineModeSetting();
            else
                Msg30xxOpenSwcapModeSetting();

            // We will setting Cfb = 50p and disable ChargePump when obtain BG of key by one shot.
            Msg30xxSetCfb(_Msg30xx50p);
            Msg30xxAnaEnableChargePump(DISABLE);
        }

    	if (Msg30xxReEnterMutualMode(fmodeKey) < 0) {
    		printk("*** Msg30xxReEnterMutualMode failed ***\n");
    	    if (keyArray != NULL)
    	    	kfree(keyArray);
    	    	return -1;
    	}

    	if (Msg30xxObtainOpenValue_Keys_FW_v1007(keyArray) < 0) {
    		printk("*** Msg30xxObtainOpenValue_Keys failed ***\n");
    	    if (keyArray != NULL)
    	    	kfree(keyArray);
    	    	return -1;
    	}

    	for (k = 0; k < numKey; k++) {
    		shift = (ptMsg30xxMutualMpTest->KeySen[k] - 1) * ptMsg30xxMutualMpTest->sensorInfo.KeyDrv_o + ptMsg30xxMutualMpTest->sensorInfo.KeyDrv_o - 1;
    		_gMsg30xxDeltaC[shift] = keyArray[k];
    		printk("_gMsg30xxDeltaC[shift = %d] = %d\n", shift, _gMsg30xxDeltaC[shift]);
    	}
    } else {
    	if(Msg30xxGetDeltaC(_gMsg30xxDeltaC, drv_mode) < 0)	{
    		printk("*** Msg30xx Open Test# GetDeltaC failed! ***\n");
    		if (keyArray != NULL)
    			kfree(keyArray);
    		return -1;
    	}
    }
    if (keyArray != NULL) {
    	printk("*** free keyArray ***\n");
    	kfree(keyArray);
    }
    return 0;
}

s32 Msg30xxopen_previous_FW_v1007(u16 nFMode)
{
    s32 *keyArray = NULL, k;
    u16 shift = 0;
    u16 drv_mode = 0;
    int numKey = 0;

    printk("*** %s(): Mode = %x ***\n", __func__, nFMode);

    // Stop mcu
    StopMCU();

    numKey = ptMsg30xxMutualMpTest->sensorInfo.numKey;
    if (MAX(numKey, 3) > 3)
    	numKey = 3;
    if (ptMsg30xxMutualMpTest->Mutual_Key != 0) {

    	if (ptMsg30xxMutualMpTest->Open_mode == 2) {
    		if(Msg30xxopen_latter_FW_v1007(nFMode) < 0) {
    			printk("*** Msg30xx Open Test# OpenTest failed! ***\n");
    		    return -1;
    		}
    	}
    	else {
    		if ((ptMsg30xxMutualMpTest->Pattern_type == 5) && (ptMsg30xxMutualMpTest->Pattern_model == 1)) {
                if (ptMsg30xxMutualMpTest->Open_KeySettingByFW)
                {
                    if (nFMode == MUTUAL_SINE)
                        Msg30xxOpenSineModeSetting();
                    else
                        Msg30xxOpenSwcapModeSetting();
                    Msg30xxSetCfb(_Msg30xx50p);
                    Msg30xxAnaEnableChargePump(DISABLE);
                }
    			keyArray = (s32 *)kcalloc(numKey, sizeof(s32), GFP_KERNEL);
    			if (Msg30xxObtainOpenValue_Keys(keyArray) < 0)
    			{
                    printk("*** Msg30xxObtainOpenValue_Keys failed ***\n");
                    if (keyArray != NULL)
                        kfree(keyArray);
                    return -1;
                }

    			if (Msg30xxReEnterMutualMode(nFMode) < 0) {
    				printk("*** Msg30xxReEnterMutualMode failed ***\n");
    				if (keyArray != NULL)
    					kfree(keyArray);
    				return -1;
    			}

    			if (nFMode == MUTUAL_SINE)
    				Msg30xxOpenSineModeSetting();
    			else
    				Msg30xxOpenSwcapModeSetting();

                if (Msg30xxObtainOpenValue_VA() < 0) {
                    printk("*** ObtainOpenValue_VA failed ***\n");
                    if (keyArray != NULL)
                        kfree(keyArray);
                    return -1;
                }

    			for (k = 0; k < numKey; k++) {
    				shift = (ptMsg30xxMutualMpTest->KeySen[k] - 1) * ptMsg30xxMutualMpTest->sensorInfo.KeyDrv_o + ptMsg30xxMutualMpTest->sensorInfo.KeyDrv_o - 1;
    				_gMsg30xxDeltaC[shift] = keyArray[k];
    			}
    		}
    		else {
    			if (nFMode == MUTUAL_SINE)
    				Msg30xxOpenSineModeSetting();
    			else
    			   	Msg30xxOpenSwcapModeSetting();

    	    	if(Msg30xxGetDeltaC(_gMsg30xxDeltaC, drv_mode) < 0)	{
    	    		printk("*** Msg30xx Open Test# GetDeltaC failed! ***\n");
    	    		if (keyArray != NULL)
    	    			kfree(keyArray);
    	    		return -1;
    	    	}
    		}
    	}
    } else {
		if (nFMode == MUTUAL_SINE)
			Msg30xxOpenSineModeSetting();
		else
		   	Msg30xxOpenSwcapModeSetting();

    	if(Msg30xxGetDeltaC(_gMsg30xxDeltaC, drv_mode) < 0)	{
    		printk("*** Msg30xx Open Test# GetDeltaC failed! ***\n");
    		if (keyArray != NULL)
    			kfree(keyArray);
    		return -1;
    	}
    }
    if (keyArray != NULL) {
    	printk("*** free keyArray ***\n");
    	kfree(keyArray);
    }
    return 0;
}


u16 normalTestFail_check_Deltac_msg30xx[MAX_MUTUAL_NUM];
u16 normalTestFail_check_Ratio_msg30xx[MAX_MUTUAL_NUM];
#ifdef DISABLE_DOUBLE
int ratio_border_msg30xx[MAX_MUTUAL_NUM];
int ratio_move_msg30xx[MAX_MUTUAL_NUM];
int ratio_border_move_msg30xx[MAX_MUTUAL_NUM];
int ratio_msg30xx[MAX_MUTUAL_NUM];
#else
double ratio_msg30xx[MAX_MUTUAL_NUM];
double ratio_border_msg30xx[MAX_MUTUAL_NUM];
double ratio_move_msg30xx[MAX_MUTUAL_NUM];
double ratio_border_move_msg30xx[MAX_MUTUAL_NUM];
#endif


s32 Msg30xxOpenJudge(u16 nItemID, s8 *pNormalTestResult, u16 *pNormalTestResultCheck)
{
    s32 nRetVal = 0;
    u16 nCSub = ptMsg30xxMutualMpTest->Open_test_csub;
    u16 nRowNum = 0, nColumnNum = 0;
    u16 i, j, k;
    u16 nCfb;
    s32 bg_per_csub;
#ifdef DISABLE_DOUBLE
    int ratioAvg = 0.0, ratioAvg_max = 0.0, ratioAvg_min = 0.0, passCount = 0.0;
    int ratioAvg_border = 0.0, ratioAvg_border_max = 0.0, ratioAvg_border_min = 0.0, passCount1 = 0.0;
    int ratioAvg_move = 0.0, ratioAvg_border_move = 0.0;
#else
    double ratioAvg = 0.0, ratioAvg_max = 0.0, ratioAvg_min = 0.0, passCount = 0.0;
    double ratioAvg_border = 0.0, ratioAvg_border_max = 0.0, ratioAvg_border_min = 0.0, passCount1 = 0.0;
    double ratioAvg_move = 0.0, ratioAvg_border_move = 0.0;
#endif

    printk("*** %s() ***\n", __func__);

    if ((ptMsg30xxMutualMpTest->Open_mode == 1) || (ptMsg30xxMutualMpTest->Open_mode == 2))// if open mode = 1 (sine mode), Csub must be zero.
    	nCSub = 0;

    if (!ptMsg30xxMutualMpTest->Open_test_cfb)
    	nCfb = 2;
    else
    	nCfb = ptMsg30xxMutualMpTest->Open_test_cfb;

#ifndef DISABLE_DOUBLE
        bg_per_csub = (int)(2.4 * 1.17 * 32768 / (11 * nCfb));
#else
        bg_per_csub = (int)(92012 / (11 * nCfb));
#endif

    for (i = 0; i < _gMsg30xxSenseLineNum * _gMsg30xxDriveLineNum; i++)
    {
        if (_gMsg30xxDeltaC[i] > 31000)
        {
            return -1;
        }

        if (_gMsg30xxDeltaC[i] != UN_USE_SENSOR)
        {
        	if (_gMsg30xxsssqrt_en)
                _gResult_msg30xx[i] = _gMsg30xxDeltaC[i];
        	else
        	   	_gResult_msg30xx[i] = bg_per_csub * nCSub - _gMsg30xxDeltaC[i];
        }
        else
        	_gResult_msg30xx[i] = NULL_DATA;

        // For mutual key, last column if not be used, show number "one".
        if ((ptMsg30xxMutualMpTest->Mutual_Key == 1 || ptMsg30xxMutualMpTest->Mutual_Key == 2) && (ptMsg30xxMutualMpTest->sensorInfo.numKey != 0))
        {
        	if (ptMsg30xxMutualMpTest->Pattern_type == 5)
        	{
        		// KEY_CH = 1, it mean keys in same drive. Current one key project only KEY_CH = 1 type.
        		if (ptMsg30xxMutualMpTest->sensorInfo.KEY_CH != ptMsg30xxMutualMpTest->sensorInfo.numKey)
        		{
        			if (!((i + 1) % ptMsg30xxMutualMpTest->sensorInfo.numDrv))
        			{
        				_gResult_msg30xx[i] = NULL_DATA;
        				for (k = 0; k < ptMsg30xxMutualMpTest->sensorInfo.numKey; k++)
        					if ((i + 1) / _gMsg30xxDriveLineNum == ptMsg30xxMutualMpTest->KeySen[k])
        					{
        						if (_gMsg30xxsssqrt_en)
                                    _gResult_msg30xx[i] = _gMsg30xxDeltaC[i];
                                else
                                    _gResult_msg30xx[i] = bg_per_csub * nCSub - _gMsg30xxDeltaC[i];
        					}
        			}
        		}
        		else
        		{
        			if (i > ((ptMsg30xxMutualMpTest->sensorInfo.numSen - 1) * ptMsg30xxMutualMpTest->sensorInfo.numDrv - 1))
        			{
        				_gResult_msg30xx[i] = NULL_DATA;
        				for (k = 0; k < ptMsg30xxMutualMpTest->sensorInfo.numKey; k++)
        					if (((i + 1) - (_gMsg30xxSenseLineNum - 1) * _gMsg30xxDriveLineNum) == ptMsg30xxMutualMpTest->KeySen[k])
        				    {
        						if (_gMsg30xxsssqrt_en)
                                    _gResult_msg30xx[i] = _gMsg30xxDeltaC[i];
                                else
                                    _gResult_msg30xx[i] = bg_per_csub * nCSub - _gMsg30xxDeltaC[i];
        				    }
        			}
        		}
        	}
        	else
        	{
        		if ((_gMsg30xxSenseLineNum < _gMsg30xxDriveLineNum) && ((i + 1) % _gMsg30xxDriveLineNum == 0))
        		{
        			_gResult_msg30xx[i] = NULL_DATA;
        			for (k = 0; k < ptMsg30xxMutualMpTest->sensorInfo.numKey; k++)
        				if ((i + 1) / _gMsg30xxDriveLineNum == ptMsg30xxMutualMpTest->KeySen[k])
        				{
        					if (_gMsg30xxsssqrt_en)
                                _gResult_msg30xx[i] = _gMsg30xxDeltaC[i];
                            else
                                _gResult_msg30xx[i] = bg_per_csub * nCSub - _gMsg30xxDeltaC[i];
        				}
        		}

        		if ((_gMsg30xxSenseLineNum > _gMsg30xxDriveLineNum) && (i > (_gMsg30xxSenseLineNum - 1) * _gMsg30xxDriveLineNum - 1))
        		{
        			_gResult_msg30xx[i] = NULL_DATA;
        			for (k = 0; k < ptMsg30xxMutualMpTest->sensorInfo.numKey; k++)
        			{
        				if (((i + 1) - (_gMsg30xxSenseLineNum - 1) * _gMsg30xxDriveLineNum) == ptMsg30xxMutualMpTest->KeySen[k])
        				{
        					if (_gMsg30xxsssqrt_en)
                                _gResult_msg30xx[i] = _gMsg30xxDeltaC[i];
                            else
                                _gResult_msg30xx[i] = bg_per_csub * nCSub - _gMsg30xxDeltaC[i];
        				}
        			} //  for (k = 0; k < ptMsg30xxMutualMpTest->sensorInfo.numKey; k++)
        		} // if ((_gMsg30xxSenseLineNum > _gMsg30xxDriveLineNum) && (i > (_gMsg30xxSenseLineNum - 1) * _gMsg30xxDriveLineNum - 1))
        	}
        }
    }

    memset(normalTestFail_check_Deltac_msg30xx, 0xFFFF, sizeof(normalTestFail_check_Deltac_msg30xx));
    memset(normalTestFail_check_Ratio_msg30xx, 0xFFFF, sizeof(normalTestFail_check_Ratio_msg30xx));
    memset(ratio_msg30xx,0,sizeof(ratio_msg30xx));
    memset(ratio_border_msg30xx,0,sizeof(ratio_border_msg30xx));
    memset(ratio_move_msg30xx,0,sizeof(ratio_move_msg30xx));
    memset(ratio_border_move_msg30xx,0,sizeof(ratio_move_msg30xx));

    nRowNum = _gMsg30xxDriveLineNum;
    nColumnNum = _gMsg30xxSenseLineNum;

    printk("*** Msg30xx Open Test# Show _gResult ***\n");
    DebugShowArray2(_gResult_msg30xx, nRowNum*nColumnNum, -32, 10, nColumnNum);
    printk("*** Msg30xx Open Test# Show Goldensample ***\n");
    DebugShowArray2(ptMsg30xxMutualMpTest->Goldensample_CH_0, nRowNum*nColumnNum, -32, 10, nColumnNum);

    for (k = 0; k < (sizeof(_gMsg30xxDeltaC) / sizeof(_gMsg30xxDeltaC[0])); k++)
    {
    	if (0 == ptMsg30xxMutualMpTest->Goldensample_CH_0[k]) {
    		if (k == 0)
    			pNormalTestResult[0] = 1;	// no golden sample
    		break;
    	}

    	if (_gResult_msg30xx[k] != NULL_DATA)
    	{
    		ratio_msg30xx[k] = (_gResult_msg30xx[k] * 1000) / ptMsg30xxMutualMpTest->Goldensample_CH_0[k];

    		if (0 == CheckValueInRange(_gResult_msg30xx[k], ptMsg30xxMutualMpTest->Goldensample_CH_0_Max[k], ptMsg30xxMutualMpTest->Goldensample_CH_0_Min[k]))
    		{
    			pNormalTestResult[0] = 1;
    			pNormalTestResultCheck[k] = (u16)(((k / _gMsg30xxDriveLineNum) + 1) * 100 + ((k % _gMsg30xxDriveLineNum) + 1));
    		}
    		else
    		{
    			pNormalTestResultCheck[k] = PIN_NO_ERROR;
    			if ((ptMsg30xxMutualMpTest->Pattern_type == 3) && (ptMsg30xxMutualMpTest->sensorInfo.numKey == 0) && ((k % _gMsg30xxDriveLineNum == 0 )||((k + 1) % _gMsg30xxDriveLineNum == 0)))
    			{
    				ratioAvg_border += ratio_msg30xx[k];
    				passCount1 += 1;
    			}
    			else if ((ptMsg30xxMutualMpTest->Pattern_type == 3) && (ptMsg30xxMutualMpTest->sensorInfo.numKey != 0) && ((k % _gMsg30xxDriveLineNum == 0) || ((k + 2) % _gMsg30xxDriveLineNum == 0)))
    			{
    				ratioAvg_border += ratio_msg30xx[k];
    				passCount1 += 1;
    			}
    			else
    			{
    				ratioAvg += ratio_msg30xx[k];
    				passCount += 1;
    			}
    		}
    	}
    	else
    	{
    		pNormalTestResultCheck[k] = PIN_NO_ERROR;
    	}
    	normalTestFail_check_Deltac_msg30xx[k] = pNormalTestResultCheck[k];
    }

    printk("*** Msg30xx Open Test# normalTestFail_check_Deltac Channel ***\n");
    //printkShowArray2(normalTestFail_check_Deltac, nRowNum*nColumnNum, 16, 16, nColumnNum);	// printk sign 32 decimal value array

#ifdef DISABLE_DOUBLE
    ratioAvg_max = (int)(100000 + (ptMsg30xxMutualMpTest->ToastInfo.persentDC_VA_Ratio * 1000) + (ptMsg30xxMutualMpTest->ToastInfo.persentDC_VA_Ratio_up * 1000)) / 100;
    ratioAvg_min = (int)(100000 - (ptMsg30xxMutualMpTest->ToastInfo.persentDC_VA_Ratio * 1000)) / 100;

    ratioAvg_border_max=(int)(100000 + (ptMsg30xxMutualMpTest->ToastInfo.persentDC_Border_Ratio * 1000) + (ptMsg30xxMutualMpTest->ToastInfo.persentDC_VA_Ratio_up * 1000)) / 100;
    ratioAvg_border_min = (int)(100000 - (ptMsg30xxMutualMpTest->ToastInfo.persentDC_Border_Ratio * 1000)) / 100;
#else
    ratioAvg_max = (double)(100 + ptMsg30xxMutualMpTest->ToastInfo.persentDC_VA_Ratio + ptMsg30xxMutualMpTest->ToastInfo.persentDC_VA_Ratio_up) / 100.0;
    ratioAvg_min = (double)(100 - ptMsg30xxMutualMpTest->ToastInfo.persentDC_VA_Ratio) / 100.0;

    ratioAvg_border_max=(double)(100 + ptMsg30xxMutualMpTest->ToastInfo.persentDC_Border_Ratio + ptMsg30xxMutualMpTest->ToastInfo.persentDC_VA_Ratio_up) / 100.0;
    ratioAvg_border_min = (double)(100 - ptMsg30xxMutualMpTest->ToastInfo.persentDC_Border_Ratio) / 100.0;
#endif

    if (passCount != 0)
    {
        if (passCount1 != 0)
        {
            ratioAvg_border_move = ratioAvg_border / passCount1;

            ratioAvg_move = ratioAvg / passCount;

            for (i = 0; i < sizeof(ratio_msg30xx) / sizeof(ratio_msg30xx[0]); i++)
            {
                if ((ptMsg30xxMutualMpTest->sensorInfo.numKey == 0) && ((i % _gMsg30xxDriveLineNum == 0) || ((i + 1) % _gMsg30xxDriveLineNum == 0)))
                {
                    ratio_move_msg30xx[i] = ratio_msg30xx[i] - ratioAvg_border_move + 1;
                }
                else if ((ptMsg30xxMutualMpTest->sensorInfo.numKey != 0) && ((i % _gMsg30xxDriveLineNum == 0) || ((i + 2) % _gMsg30xxDriveLineNum == 0)))
                {
                      ratio_move_msg30xx[i] = ratio_msg30xx[i] - ratioAvg_border_move + 1;
                }
                else
                {
                    ratio_move_msg30xx[i] = ratio_msg30xx[i] - ratioAvg_move + 1;
                }

            }
        }
        else
        {
            ratioAvg_move = ratioAvg / passCount;

            for (i = 0; i < sizeof(ratio_msg30xx) / sizeof(ratio_msg30xx[0]); i++)
            {
               ratio_move_msg30xx[i] = ratio_msg30xx[i] - ratioAvg_move + 1;
            }
        }
    }
    else
    {
        memcpy(ratio_msg30xx, ratio_move_msg30xx, sizeof(ratio_msg30xx));
    }

    for (j = 0; j < (sizeof(_gMsg30xxDeltaC) / sizeof(_gMsg30xxDeltaC[0])); j++)
    {
        if (0 == ptMsg30xxMutualMpTest->Goldensample_CH_0[j]) {
        	if (j == 0)
        		pNormalTestResult[1] = 1;	// no golden sample
        	break;
        }

        if (PIN_NO_ERROR == pNormalTestResultCheck[j])
        {
            if (_gResult_msg30xx[j] != NULL_DATA)
            {
                if ((ptMsg30xxMutualMpTest->Pattern_type == 3) && (ptMsg30xxMutualMpTest->sensorInfo.numKey == 0) && ((j % _gMsg30xxDriveLineNum == 0) || ((j + 1) % _gMsg30xxDriveLineNum == 0)))
                {
                    if (0 == checkDoubleValueInRange(ratio_move_msg30xx[j], ratioAvg_border_max, ratioAvg_border_min))
                    {
                    	pNormalTestResult[1] = 1;
                    	pNormalTestResultCheck[j] = (u16)(((j / _gMsg30xxDriveLineNum) + 1) * 100 + ((j % _gMsg30xxDriveLineNum) + 1));
                    }
                    else
                    {
                    	pNormalTestResultCheck[j] = PIN_NO_ERROR;
                    }
                }
                else if ((ptMsg30xxMutualMpTest->Pattern_type == 3) && (ptMsg30xxMutualMpTest->sensorInfo.numKey != 0) && ((j % _gMsg30xxDriveLineNum == 0) || ((j + 2) % _gMsg30xxDriveLineNum == 0)))
                {
                    if (0 == checkDoubleValueInRange(ratio_move_msg30xx[j], ratioAvg_border_max, ratioAvg_border_min))
                    {
                    	pNormalTestResult[1] = 1;
                    	pNormalTestResultCheck[j] = (u16)(((j / _gMsg30xxDriveLineNum) + 1) * 100 + ((j % _gMsg30xxDriveLineNum) + 1));
                    }
                    else
                    {
                    	pNormalTestResultCheck[j] = PIN_NO_ERROR;
                    }
                }
                else
                {
                	//printk("ratiomove[%d] = %f, ratioAvg_max = %f, ratioAvg_min = %f",j,ratio_move[j], ratioAvg_max, ratioAvg_min);
                    if (0 == checkDoubleValueInRange(ratio_move_msg30xx[j], ratioAvg_max, ratioAvg_min))
                    {
                    	pNormalTestResult[1] = 1;
                    	pNormalTestResultCheck[j] = (u16)(((j / _gMsg30xxDriveLineNum) + 1) * 100 + ((j % _gMsg30xxDriveLineNum) + 1));
                    }
                    else
                    {
                    	pNormalTestResultCheck[j] = PIN_NO_ERROR;
                    }
                }
            }
            else
            {
            	pNormalTestResultCheck[j] = PIN_NO_ERROR;
            }
        }
        else
        {
            normalTestFail_check_Ratio_msg30xx[j] = pNormalTestResultCheck[j];
            continue;
        }
        normalTestFail_check_Ratio_msg30xx[j] = pNormalTestResultCheck[j];
    }

    printk("*** Msg30xx Open Test# normalTestFail_check_Ratio Channel ***\n");
    //printkShowArray2(normalTestFail_check_Ratio, nRowNum*nColumnNum, 16, 16, nColumnNum);	// printk sign 32 decimal value array

    for (k = 0; k < MAX_MUTUAL_NUM; k++)
    {
        if (0 == ptMsg30xxMutualMpTest->Goldensample_CH_0[k])
        {
        	pNormalTestResultCheck[k] = PIN_NO_ERROR;
            normalTestFail_check_Deltac_msg30xx[k] = PIN_NO_ERROR;
            normalTestFail_check_Ratio_msg30xx[k] = PIN_NO_ERROR;
        }
        else
        {
            continue;
        }
    }

    if ((pNormalTestResult[0] != 0) || (pNormalTestResult[1] != 0))
    	nRetVal = -1;

    for (i = 0; i < 2; i++)
    {
    	ptMsg30xxMutualMpTestResult->pCheck_Fail[i] = pNormalTestResult[i];
    }
    for (i = 0; i < sizeof(normalTestFail_check_Deltac_msg30xx) / sizeof(normalTestFail_check_Deltac_msg30xx[0]); i++)	// reduce memory operation instead of memcpy
    {
    	ptMsg30xxMutualMpTestResult->pOpenFailChannel[i] = normalTestFail_check_Deltac_msg30xx[i];
    	ptMsg30xxMutualMpTestResult->pOpenRatioFailChannel[i] = normalTestFail_check_Ratio_msg30xx[i];
    	ptMsg30xxMutualMpTestResult->pGolden_CH_Max_Avg[i] = ratio_move_msg30xx[i];
    }

    return nRetVal;
}

int Msg30xxFixCarrierFrequency(u16 fmode, u8 Freq, u8 Freq1, u16 code_type) //201703xx
{
    u8 nFreq = Freq, nFreq1 = Freq1, nDAC = 1;
    int i, nRet = 1, curFreq = 0, setFreq = 0;
    u16 nRegData = 0;
    u8 cmd[4] = {0};

    printk("*** %s() ***\n", __func__);

    nFreq = MAX(nFreq, 0);
    nFreq = MIN(nFreq, 255);
    cmd[0] = 0x0B;
    cmd[1] = 0x01;
    cmd[2] = nFreq;

    if (code_type == TWO_DAC_ENABLE)
    {
        nFreq1 = MAX(nFreq1, 0);
        nFreq1 = MIN(nFreq1, 255);
        cmd[3] = nFreq1;
        nDAC = 2;
    }
    IicWriteData(SLAVE_I2C_ID_DWI2C, &cmd[0], sizeof(cmd) / sizeof(u8));
    Msg30xxReEnterMutualMode(fmode);

    for (i = 0; i < nDAC; i++)
    {
        nRegData = RegGet16BitValueByAddressMode(0x2003 + i * 0x40, ADDRESS_MODE_16BIT);
        curFreq = (int)(nRegData * (13000000 / 16384) / 1000); //khz
        setFreq = (i == 0) ? nFreq : nFreq1;

        if (abs(curFreq - setFreq) >= 2) {
            printk("Fixed carrier DAC%d failed, current frequency = %d khz, need fixed frequency = %d khz", i, curFreq, setFreq);
            return 0;
        }
    }
    return nRet;
}

u16 sine_method_detection(void)
{
    u16 nRegdata = 0;

    nRegdata = RegGet16BitValueByAddressMode(0x1301, ADDRESS_MODE_16BIT);
    return (((nRegdata & BIT7) == BIT7) ? 1 : 0);
}

u16 nNormalTestResultCheck_msg30xx[MAX_MUTUAL_NUM] = {0};        //6:max subframe    13:max afe

int Msg30xxOpenTestEntry(u16 fw_ver)
{
	u16 fmode = MUTUAL_MODE, i;
    s32 nRetVal = 0;
    s8 nNormalTestResult[2] = {0};    //0:golden    1:ratio
    u8 time = 0;
    u16 deep_standby = ptMsg30xxMutualMpTest->deep_standby;

    printk("*** %s() ***\n", __func__);
    _gMsg30xxSenseLineNum = ptMsg30xxMutualMpTest->sensorInfo.numSen;
    _gMsg30xxDriveLineNum = ptMsg30xxMutualMpTest->sensorInfo.numDrv;
    _gResult_msg30xx = ptMsg30xxMutualMpTestResult->pOpenResultData;

_retry_open:

    DrvDisableFingerTouchReport();
    DrvTouchDeviceHwReset();
    EnterDBBus();
    mdelay(100);

    // Stop mcu
    StopMCU();

    switch (ptMsg30xxMutualMpTest->Open_mode) {
    	case 0:
    		fmode = MUTUAL_MODE;
    		break;
    	case 1:
    	case 2:
    		fmode = MUTUAL_SINE;
    		break;
    }

    if(Msg30xxSwitchFwMode(&fmode, &deep_standby) < 0)
    {
        printk("*** Msg30xx Open Test# SwitchFwMode failed! ***\n");
        time++;
        if (time < 10)
        	goto _retry_open;
        else {
            for (i = 0; i < 2; i++)
            {
                ptMsg30xxMutualMpTestResult->pCheck_Fail[i] = 1;
            }
            for (i = 0; i < MAX_MUTUAL_NUM; i++)	// reduce memory operation instead of memcpy
            {
                ptMsg30xxMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
                ptMsg30xxMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
            }
        	nRetVal = -1;
        	goto ITO_TEST_END;
        }
    }
    if (fmode == MUTUAL_SINE)
    {   //printk IVO
        if (!Msg30xxFixCarrierFrequency(fmode, ptMsg30xxMutualMpTest->Open_fixed_carrier, ptMsg30xxMutualMpTest->Open_fixed_carrier1, _gMsg30xxTwoDACEnable))
        {
            for (i = 0; i < 2; i++)
            {
                ptMsg30xxMutualMpTestResult->pCheck_Fail[i] = 1;
            }
            for (i = 0; i < MAX_MUTUAL_NUM; i++)	// reduce memory operation instead of memcpy
            {
                ptMsg30xxMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
                ptMsg30xxMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
            }
            return -1;
        }
    }

    _gMsg30xxsssqrt_en = sine_method_detection();

    if (fw_ver == 0x0007) {
    	if ((_gMsg30xxScanMode != KEY_SEPERATE) && (_gMsg30xxScanMode != KEY_COMBINE))
    		_gMsg30xxScanMode = KEY_SEPERATE;
    }
    else if (fw_ver < 0x0007){
    	_gMsg30xxScanMode = KEY_COMBINE;
    }
    //_gMsg30xxScanMode = KEY_SEPERATE;
    if (_gMsg30xxScanMode == KEY_SEPERATE) {
    	printk("fmode = %x\n", fmode);
    	if(Msg30xxopen_latter_FW_v1007(fmode) < 0) {
    		printk("*** Msg30xx Open Test# OpenTest failed! ***\n");
    		for (i = 0; i < 2; i++)
            {
                ptMsg30xxMutualMpTestResult->pCheck_Fail[i] = 1;
            }
            for (i = 0; i < MAX_MUTUAL_NUM; i++)	// reduce memory operation instead of memcpy
            {
                ptMsg30xxMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
                ptMsg30xxMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
            }
    		nRetVal = -1;
    		goto ITO_TEST_END;
    	}
    }
    else {
    	printk("fmode = %x\n", fmode);
    	if(Msg30xxopen_previous_FW_v1007(fmode) < 0) {
    		printk("*** Msg30xx Open Test# OpenTest failed! ***\n");
    		for (i = 0; i < 2; i++)
            {
                ptMsg30xxMutualMpTestResult->pCheck_Fail[i] = 1;
            }
            for (i = 0; i < MAX_MUTUAL_NUM; i++)	// reduce memory operation instead of memcpy
            {
                ptMsg30xxMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
                ptMsg30xxMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
            }
    	    nRetVal = -1;
    	    goto ITO_TEST_END;
    	}
    }

    mdelay(10);

    nRetVal = Msg30xxOpenJudge(0, nNormalTestResult, nNormalTestResultCheck_msg30xx);
    printk("*** Msg30xx Open Test# OpenTestOpenJudge return value = %d ***\n", nRetVal);

    ExitDBBus();

ITO_TEST_END:

    DrvTouchDeviceHwReset();
    mdelay(300);
    DrvEnableFingerTouchReport();

    return nRetVal;
}


int Msg30xxOpenTest(u16 fw_ver)
{
    int nRetVal = 0;
    int nRet = 0;


    nRetVal = Msg30xxOpenTestEntry(fw_ver);
    if (nRetVal == 0){
    	nRet = ITO_TEST_OK; //PASS
        printk("Msg30xx Open Test# MP test success\n");
    }else{
    	if(nRetVal == -1){
    	    nRet = ITO_TEST_FAIL;
        }
        else if (nRetVal == -2){
            nRet = ITO_TEST_GET_TP_TYPE_ERROR;
        }
        else{
            nRet = ITO_TEST_UNDEFINED_ERROR;
        }

        printk("Msg30xx Open Test# MP test failed\n");
    }

    return nRet;
}

